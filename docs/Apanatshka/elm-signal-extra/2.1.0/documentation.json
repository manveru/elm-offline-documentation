[
  {
    "name": "Signal.Time",
    "comment": "Time related functions for `Signal`s.\n\n# Easy does it\nControlling too frequently changing signals. \n@docs limitRate, dropWithin, settledAfter\n\n# Re-exports\nSome functions from the `Time` module that fit in. \n@docs since, delay, timestamp",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "delay",
        "comment": "A re-export of [Time.delay](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Time#delay). \n\nDelay a signal by a certain amount of time. So `(delay second\nMouse.clicks)` will update one second later than any mouse click.",
        "type": "Time -> Signal a -> Signal a"
      },
      {
        "name": "dropWithin",
        "comment": "Drops all but the first update of a flurry of updates (a stutter).\nThe stutter is defined as updates that happen with max. the given time\nin between. \n\nThe first update of the given signal is sent through. Then the given\ndelay is waited. If no other updates arrive during that time, then next\nupdate will be sent through. Any update that arrives within the given\ntime of the last update is dropped. \n\n    noDoubleClicks = dropWithin (300 * milliseconds) Mouse.clicks\n\nAlso known to some areas as an \"immediate\" `debounce` function.",
        "type": "Time -> Signal a -> Signal a"
      },
      {
        "name": "limitRate",
        "comment": "Limits the given signal to the given frequency. \n\nAfter an update of the given signal, for 1 / the given frequency seconds\nsubsequent updates are dropped. The original update that started this\ndropping is kept. \n\n    throttledMouseClicks = limitRate 60 Mouse.clicks\n\nAlso known in some areas as a `throttle` function.",
        "type": "number -> Signal a -> Signal a"
      },
      {
        "name": "settledAfter",
        "comment": "Gives the last update of a flurry of updates (a stutter) after has\nsettled* for the given time. The stutter is defined as updates that\nhappen within the given time. * Where settled the signal gets no further\nupdates for some time, it's **not** relating to the value changes of the\nsignal. \n\nAfter every update of the given signal, the given delay is waited. If no\nother updates arrived during that time, the update is sent through. If a\nnew update arrives within the given time, the previous update is dropped\nand the waiting is restarted. So `debounce`-ing a signal that keeps up\nthe flurry of updates all the time results in a signal that never\nupdates. \n\n    tooltip : Signal Bool\n    tooltip = \n      merge (always False <~ Mouse.position) \n            (always True <~ (Mouse.position\n                            |> settledAfter (500 * Time.millisecond)))\n\nAlso known in some areas as a `debounce` function.",
        "type": "Time -> Signal a -> Signal a"
      },
      {
        "name": "since",
        "comment": "A re-export of [Time.since](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Time#since). \n\nTakes a time `t` and any signal. The resulting boolean signal is true\nfor time `t` after every event on the input signal. So ``(second `since`\nMouse.clicks)`` would result in a signal that is true for one second\nafter each mouse click and false otherwise.",
        "type": "Time -> Signal a -> Signal Bool"
      },
      {
        "name": "timestamp",
        "comment": "A re-export of [Time.timestamp](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Time#timestamp). \n\nAdd a timestamp to any signal. Timestamps increase monotonically. When\nyou create `(timestamp Mouse.x)`, an initial timestamp is produced. The\ntimestamp updates whenever `Mouse.x` updates.\n\nTimestamp updates are tied to individual events, so `(timestamp\nMouse.x)` and `(timestamp Mouse.y)` will always have the same timestamp\nbecause they rely on the same underlying event (`Mouse.position`).",
        "type": "Signal a -> Signal ( Time, a )"
      }
    ],
    "generated-with-elm-version": "old"
  },
  {
    "name": "Signal.Extra",
    "comment": "Utility functions that aren't in the `Signal` module from\n`elm-lang/core`. \n\n# Flipped fancy map\n@docs (~>)\n\n# Zipping and unzipping\nFor those too lazy to write a record or ADT.  \n@docs zip, zip3, zip4, unzip, unzip3, unzip4\n\n# Stateful\n@docs foldp', foldps, foldps', last, delayRound\n\n# Old filters\nThe way they used to work, with weird value propagation. \n@docs keepWhenS, dropWhenS",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "delayRound",
        "comment": "Instead of delaying for some amount of time, delay for one round,\nwhere a round is initiated by outside event to the Elm program. \nAlso known to `delay` in E-FRP.",
        "type": "b -> Signal b -> Signal b"
      },
      {
        "name": "foldp'",
        "comment": "",
        "type": "(a -> b -> b) -> (a -> b) -> Signal a -> Signal b"
      },
      {
        "name": "foldps",
        "comment": "Like `foldp`, but with a hidden state\n\n    foldp f b i ==\n      let d a = (a,a) -- doubling function\n      in foldps (\\a b -> f a b |> d) (d b) i",
        "type": "(a -> s -> ( b, s )) -> ( b, s ) -> Signal a -> Signal b"
      },
      {
        "name": "foldps'",
        "comment": "Like `foldp'`, but with a hidden state",
        "type": "(a -> s -> ( b, s )) -> (a -> ( b, s )) -> Signal a -> Signal b"
      },
      {
        "name": "runBuffer",
        "comment": "A running buffer of the given size (`n`) of the given signal. \nThe list of at most `n` of the last values on the input signal. Starts\nwith an empty list. Adds new values to the *end* of the list! So you get\na list with time going from left to right. \n\n    ((==) [1,2,3,4,5]) <~ runBuffer 5 (count (Time.every second))",
        "type": "Int -> Signal a -> Signal (List a)"
      },
      {
        "name": "runBuffer'",
        "comment": "Same as `runBuffer` but with an initial buffer.",
        "type": "List a -> Int -> Signal a -> Signal (List a)"
      },
      {
        "name": "sampleWhen",
        "comment": "A combination of `Signal.sampleOn` and `Signal.keepWhen`. When the\nfirst signal becomes `True`, the most recent value of the second signal\nwill be propagated.  \n[Before Elm 0.12](\nhttps://github.com/elm-lang/elm-compiler/blob/master/changelog.md#012)\n this was the standard behaviour of `keepWhen`.",
        "type": "Signal Bool -> a -> Signal a -> Signal a"
      },
      {
        "name": "unzip",
        "comment": "unzip a zipped pair of signals\n\n    unzip Mouse.position == (Mouse.x, Mouse.y)",
        "type": "Signal ( a, b ) -> ( Signal a, Signal b )"
      },
      {
        "name": "unzip3",
        "comment": "unzip three signals",
        "type": "Signal ( a, b, c ) -> ( Signal a, Signal b, Signal c )"
      },
      {
        "name": "unzip4",
        "comment": "unzip four signals",
        "type": "Signal ( a, b, c, d ) -> ( Signal a, Signal b, Signal c, Signal d )"
      },
      {
        "name": "zip",
        "comment": "zip two signals\n\n    zip Mouse.x Mouse.y == Mouse.position",
        "type": "Signal a -> Signal b -> Signal ( a, b )"
      },
      {
        "name": "zip3",
        "comment": "zip three signals",
        "type": "Signal a -> Signal b -> Signal c -> Signal ( a, b, c )"
      },
      {
        "name": "zip4",
        "comment": "zip four signals",
        "type": "Signal a -> Signal b -> Signal c -> Signal d -> Signal ( a, b, c, d )"
      },
      {
        "name": "~>",
        "comment": "The `(<~)` operator, but flipped. Doesn't play well with the other\ntwo!\n\n    Mouse.x ~> toFloat >> sqrt >> round\n            >> isEven >> not\n            >> asText",
        "type": "Signal a -> (a -> b) -> Signal b",
        "associativity": "left",
        "precedence": 4
      }
    ],
    "generated-with-elm-version": "old"
  }
]