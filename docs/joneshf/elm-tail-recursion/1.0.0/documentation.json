[
  {
    "name": "TailRecursion",
    "comment": "\n# Table of Contents\n\n1. [Functions](#functions)\n1. [Example](#example)\n  1. [Mutual Recursion](#mutual-recursion)\n  1. [Direct Recursion](#direct-recursion)\n  1. [Using recurse](#using-recurse)\n  1. [Nota Bene](#nota-bene)\n  1. [Put it All Together](#put-it-all-together)\n\n## Functions\n@docs recurse\n\n## Example\n\nA simple example is in order.\nWhen writing mutually recursive functions,\nelm compiles to code that can blow the stack.\nMutual recursion isn't the only place we can get a benefit here,\nso don't read too much into the example.\n\n### Mutual Recursion\nFor instance, the following functions can blow the stack:\n\n```elm\neven : Int -> Bool\neven n =\n  case n of\n    0 ->\n      True\n    _ ->\n      odd (n - 1)\n\nodd : Int -> Bool\nodd n =\n  case n of\n    0 ->\n      False\n    _ ->\n      even (n - 1)\n```\n\nThese functions are fine for small positive values.\nBut if we apply a large `Int` (like `1000000`), elm will throw a runtime exception.\n\nThis example is trivial and contrived for a reason.\nThere are multiple ways to solve this problem better, but that's not the purpose of it.\nThe purpose is to show that even a simple pair of mutually recursive functions can cause runtime errors with elm.\n\n### Direct Recursion\n\nWe can write this tail recursively by just inlining the body of both mutual recursions.\n\n```elm\neven : Int -> Bool\neven n =\n  case n of\n    0 ->\n      True\n    _ ->\n      case (n - 1) of\n        0 ->\n          False\n        _ ->\n          even ((n - 1) - 1)\n\nodd : Int -> Bool\nodd n =\n  case n of\n    0 ->\n      False\n    _ ->\n      case (n - 1) of\n        0 ->\n          True\n        _ ->\n          odd ((n - 1) - 1)\n```\n\nAfter a bit of cleanup, it's even understandable!\n\n```elm\neven : Int -> Bool\neven n =\n  case n of\n    0 ->\n      True\n    1 ->\n      False\n    _ ->\n      even (n - 2)\n\nodd : Int -> Bool\nodd n =\n  case n of\n    0 ->\n      False\n    1 ->\n      True\n    _ ->\n      odd (n - 2)\n```\n\nA very clean and elegant solution, but a solution that removes the inherent mutual recursion of the original.\nEvery problem we face with mutual recursion isn't always so easily changed.\nPerhaps even more important is that converting mutual recursion to direct recursion can't always happen.\n\n### Using [`recurse`][recurse]\n\nThere's another solution we could have arrived at though.\nOne that keeps the mutual recursion but protects ourselves from blowing the stack.\nIf we extract the base and inductive cases out,\nwe can use [`recurse`][recurse] instead.\n\nWe need to supply a function `(a -> Result b a)` and `a` to [`recurse`][recurse].\nThe `a` will be `Int`, as that's the input type of `even`/`odd`.\nThe `b` will be `Bool`, as that's the return type of `even`/`odd`.\n\nSo we need to create a function `Int -> Result Bool Int`.\nLet's look at `even` first.\nIf the `Int` is `0`, we're done, we know what value to returnâ€”`True`.\nIf the `Int` is anything else, we're not done.\nWe need to recurse with the predecessor.\n\nSimilar logic works for the `odd` step.\n\n```elm\nevenStep : Int -> Result Bool Int\nevenStep n =\n  case n of\n    0 ->\n      Err True\n    _ ->\n      Ok (n - 1)\n\noddStep : Int -> Result Bool Int\noddStep n =\n  case n of\n    0 ->\n      Err False\n    _ ->\n      Ok (n - 1)\n```\n\n### Nota Bene\n\nIt's important to notice that we're not doing any actual recursion here.\nWe're just converting `Int`s into `Result Bool Int`.\nI think most people will agree that it's much easier to understand and test non-recursive functions\nthan recursive functions.\n\n### Put it All Together\n\nNow that we have our \"recursive\" functions, we need to put them to use with [`recurse`][recurse].\nFor the `even` function, we want to follow the ideas of our original implementation.\nWe first take an even step, and then we take an odd step.\nFor the `odd` function, we first take an odd step, and then we take an even step\nThe functions almost write themselves.\n\n```elm\neven : Int -> Bool\neven =\n  recurse <| \\n ->\n    evenStep n `Result.andThen` oddStep\n\nodd : Int -> Bool\nodd =\n  recurse <| \\n ->\n    oddStep n `Result.andThen` evenStep\n```\n\nNotice that we can lean on the our good friend `Result.andThen`.\nAll of our functions that we know and use are still applicable here.\nWe don't need to attempt to learn some new abstractions to use [`recurse`][recurse]\n\nNow if we apply `1000000` to `even`, we'll actually get a value, rather than a runtime exception!\n\n[recurse]: #recurse\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "recurse",
        "comment": "\nIf you have a non-tail recursive function,\nuse this function to ensure it won't blow the stack.\n\nSome explanation for how this works.\n\nThanks to purity and fast-and-loose reasoning,\nwe have exactly one way to implement this function.\n\nThe only way to get a `b` is to apply an `a` to `a -> Result a b`.\nIf the result of application is `Ok a`,\nwe still don't have a `b` and must apply this new `a` to `a -> Result a b`.\nAt some point we get a value `Err b`, and thus we can finally end the recursion.\n",
        "type": "(a -> Result.Result b a) -> a -> b"
      }
    ],
    "generated-with-elm-version": "0.17.1"
  }
]