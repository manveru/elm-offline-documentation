[{"name":"Gigan.Knowledge","comment":" This module contains the \"Knowledge Base\" system, which is in essence a unique compromise between data binding\nand explicit fetching and writing.\n\nA Knowledge is datum whose state is concretely fuzzy because it must be retrieved from\nor synchronized with one or more remote services. The bulk of these functions are intended to be used together as a DSL\nthat provides very concise reductions and conditionally executed contingencies for bad data, as well as very\nsuccinct mapping from fuzzy knowledge states on to concrete views.\n\nIt is also possble to compose transformations and mapping\non to pending remote operation results, so that longer running asynchronous transformations (including fetching and manipulation)\ncan be composed as deeply as desired. The documentation is underway.\n\n# Definitions\n@docs Knowledge, KnowledgeBase, KnowledgeRecord, KnowledgeBaseDelta\n\n# Aliases for Knowledge of a KnowledgeBase or a KnowledgeRecord\n@docs BaseKnowledge, RecordKnowledge\n\n# Remote Synchronization\n@docs Remote, RemoteMap, RemoteConfig, RemoteMapConfig, QueryTask\n\n# Knowledge constructors\n@docs knowledgeOf, forbiddenKnowledge, pendingKnowledge, undecidedKnowledge, unknownKnowledge, voidKnowledge, knowledgeDo\n\n# Knowledge from Existing non-determinant Types\n@docs maybeOr, resultOr\n\n# Make Conditional Assumptions about Knowledge\n@docs assumeIf, assumeIfNot, assumeIfNow, assumeInCase, assumeInCaseNow, decideBy, doOperation, maybeKnownNow, otherwise\n\n# Transforming Knowledge\n@docs therefore, within\n\n# Conditionally Dispatch Operations on Knowledge\n@docs dispatchIf, dispatchIfNot, dispatchInCase\n\n# Basic Knowledge Predicates\n@docs isUnknown, isNotUnknown, isPending, isNotPending, isUndecided, isNotUndecided, isForbidden, isNotForbidden, isVoid, isNotVoid, isNil, isNotNil, isKnown, isNotKnown, isOperation, isNotOperation\n\n# Integrate Knowledge\n@docs knowledgeIntegrate, knowledgeQuery, knowledgeUpdate\n\n# Transforming Knowledge Base Deltas\n@docs baseDeltaMap, baseDeltaTherefore\n\n# Knowledge Base Operations\n@docs base, baseAt, baseDo, baseErrorHandler, baseIntegrate, baseMember, baseQuery, baseUpdate\n\n# Knowledge Record Operations\n@docs record, recordAt, recordBinding, recordContent, recordDo, recordErrorHandler, recordField, recordIntegrate, recordQuery, recordUpdate, reduceNotKnownNowTo\n\n# Configuration\n@docs remoteConfig, remoteErrorConfig\n\n","aliases":[{"name":"BaseKnowledge","comment":" ","args":["comparable","v"],"type":"Gigan.Knowledge.Knowledge (Gigan.Knowledge.KnowledgeBase comparable v)"},{"name":"KnowledgeBase","comment":" ","args":["comparable","v"],"type":"{ base : Gigan.Knowledge.BaseImpl comparable v , deltas : Gigan.Knowledge.BaseImpl comparable v , deltaSink : Signal.Address (Gigan.Knowledge.BaseDeltaImpl comparable v) , config : Gigan.Knowledge.RemoteMapConfig comparable v }"},{"name":"KnowledgeBaseDelta","comment":" ","args":["comparable","v"],"type":"Gigan.Knowledge.BaseDeltaImpl comparable v"},{"name":"KnowledgeRecord","comment":" ","args":["userrecord","comparable","v"],"type":"{ kbase : Gigan.Knowledge.KnowledgeBase comparable v , writes : Dict.Dict comparable (Gigan.Knowledge.Knowledge v -> userrecord -> userrecord) , reads : Dict.Dict comparable (userrecord -> Gigan.Knowledge.Knowledge v) , record : userrecord }"},{"name":"QueryTask","comment":" ","args":["never"],"type":"Task.Task never ()"},{"name":"RecordKnowledge","comment":" ","args":["userrecord","comparable","v"],"type":"Gigan.Knowledge.Knowledge (Gigan.Knowledge.KnowledgeRecord userrecord comparable v)"},{"name":"Remote","comment":" ","args":["v"],"type":"Task.Task Gigan.Error.Error (Gigan.Knowledge.Knowledge v)"},{"name":"RemoteConfig","comment":" Configures address to send remote results to, and an error handler for promoting Errors in to Knowledge. The default error handler simply promotes errors to Undecided. ","args":["v"],"type":"{ address : Signal.Address (Gigan.Knowledge.Knowledge v) , errorHandler : Gigan.Error.Error -> Gigan.Knowledge.Knowledge v }"},{"name":"RemoteMap","comment":" ","args":["comparable","v"],"type":"Dict.Dict comparable (Gigan.Knowledge.Remote v)"},{"name":"RemoteMapConfig","comment":" Configures an address per key to send remote results to, and an error handler per key for promoting Errors in to Knowledge. The default error handler simply promotes errors to Undecided.\nThe default configuration proxies a single address which accepts a KnowledgeBaseDelta. ","args":["comparable","v"],"type":"{ addressOf : comparable -> Signal.Address (Gigan.Knowledge.Knowledge v) , errorHandlerOf : comparable -> Gigan.Error.Error -> Gigan.Knowledge.Knowledge v }"}],"types":[{"name":"Knowledge","comment":" A knowledge atom. ","args":["v"],"cases":[]}],"values":[{"name":"assumeIf","comment":" If some predicate `satisfies` is satisfied by the knowledge `kb`, then we make the following\nassumption. This also applies to future knowledge implied by the existence of an Operation. ","type":"(Gigan.Knowledge.Knowledge v -> Bool) -> v -> Gigan.Knowledge.Knowledge v -> Gigan.Knowledge.Knowledge v"},{"name":"assumeIfNot","comment":" Negation of assumeIf ","type":"(Gigan.Knowledge.Knowledge v -> Bool) -> v -> Gigan.Knowledge.Knowledge v -> Gigan.Knowledge.Knowledge v"},{"name":"assumeIfNow","comment":" If the predicate is satisfied, replace the knowledge with some known value. ","type":"(Gigan.Knowledge.Knowledge v' -> Bool) -> v' -> Gigan.Knowledge.Knowledge v' -> Gigan.Knowledge.Knowledge v'"},{"name":"assumeInCase","comment":" If `possibleAssumption` yields some value `value'` when a Knowledge is applied, then\nthat value is used to overwrite the knowledge with an assumption `Known value'`, otherwise the\nKnowledge is unaffected. ","type":"(Gigan.Knowledge.Knowledge v -> Maybe.Maybe v) -> Gigan.Knowledge.Knowledge v -> Gigan.Knowledge.Knowledge v"},{"name":"assumeInCaseNow","comment":" ","type":"(Gigan.Knowledge.Knowledge v' -> Maybe.Maybe v') -> Gigan.Knowledge.Knowledge v' -> Gigan.Knowledge.Knowledge v'"},{"name":"base","comment":" ","type":"Signal.Address (Gigan.Knowledge.KnowledgeBaseDelta comparable v) -> Gigan.Knowledge.KnowledgeBase comparable v"},{"name":"baseAt","comment":" ","type":"comparable -> Gigan.Knowledge.KnowledgeBase comparable v -> Gigan.Knowledge.Knowledge v"},{"name":"baseDeltaMap","comment":" ","type":"(Gigan.Knowledge.Knowledge v -> Gigan.Knowledge.Knowledge v) -> Gigan.Knowledge.KnowledgeBaseDelta comparable v -> Gigan.Knowledge.KnowledgeBaseDelta comparable v"},{"name":"baseDeltaTherefore","comment":" ","type":"(v -> v') -> Gigan.Knowledge.KnowledgeBaseDelta comparable v -> Gigan.Knowledge.KnowledgeBaseDelta comparable v'"},{"name":"baseDo","comment":" ","type":"(Gigan.Knowledge.Knowledge v -> Gigan.Knowledge.Knowledge v) -> comparable -> Gigan.Knowledge.KnowledgeBase comparable v -> Gigan.Knowledge.KnowledgeBase comparable v"},{"name":"baseErrorHandler","comment":" ","type":"(Gigan.Error.Error -> Gigan.Knowledge.Knowledge v) -> Gigan.Knowledge.KnowledgeBase comparable v -> Gigan.Knowledge.KnowledgeBase comparable v"},{"name":"baseIntegrate","comment":" ","type":"Gigan.Knowledge.KnowledgeBase comparable v -> Gigan.Knowledge.KnowledgeBase comparable v"},{"name":"baseMember","comment":" ","type":"comparable -> Gigan.Knowledge.KnowledgeBase comparable v -> Bool"},{"name":"baseQuery","comment":" ","type":"Gigan.Knowledge.KnowledgeBase comparable v -> Maybe.Maybe (Gigan.Knowledge.QueryTask never)"},{"name":"baseUpdate","comment":" ","type":"Gigan.Knowledge.KnowledgeBaseDelta comparable v -> Gigan.Knowledge.KnowledgeBase comparable v -> Gigan.Knowledge.KnowledgeBase comparable v"},{"name":"decideBy","comment":" Offer a decision on an error classified as 'Undecided'. Undecided errors are the result of some\nproblem which may or may not be in control of the client. The problem could have been network\npartitioning related, or it could have been the result of some user input that was invalid.\nThe Knowledge state does not encode the manner in which the data was obtained, so that that\nconcern can be separated, since it would otherwise greatly complicate the knowledge primitive.\nAt this point, it should be apparent that Knowledge is the state in a state machine composed by\nsequential transformations of a Knowledge by these pipeline functions. The goal of this is clean\nimplicit causality and control flow in complex declarations about how to handle non-determinant\nstate answered by a finnicky outside oracle that may or may not make sense or be prompt. ","type":"(Gigan.Error.Error -> Gigan.Knowledge.Knowledge v) -> Gigan.Knowledge.Knowledge v -> Gigan.Knowledge.Knowledge v"},{"name":"dispatchIf","comment":" If some predicate `satisfies` is satisfied by the knowledge `kb`, then we make the following\nremote operation. ","type":"(Gigan.Knowledge.Knowledge v -> Bool) -> Gigan.Knowledge.Remote v -> Gigan.Knowledge.Knowledge v -> Gigan.Knowledge.Knowledge v"},{"name":"dispatchIfNot","comment":" Negation of dispatchIf ","type":"(Gigan.Knowledge.Knowledge v -> Bool) -> Gigan.Knowledge.Remote v -> Gigan.Knowledge.Knowledge v -> Gigan.Knowledge.Knowledge v"},{"name":"dispatchInCase","comment":" The root remote operation transformation which maybe produces a remote task. If it does, then that becomes\nan Operation, otherwise the Knowledge is unaffected. ","type":"(Gigan.Knowledge.Knowledge v -> Maybe.Maybe (Gigan.Knowledge.Remote v)) -> Gigan.Knowledge.Knowledge v -> Gigan.Knowledge.Knowledge v"},{"name":"doOperation","comment":" ","type":"Gigan.Knowledge.Remote v -> Gigan.Knowledge.Knowledge v"},{"name":"forbiddenKnowledge","comment":" ","type":"Gigan.Error.Error -> Gigan.Knowledge.Knowledge v"},{"name":"isForbidden","comment":" ","type":"Gigan.Knowledge.Knowledge v -> Bool"},{"name":"isKnown","comment":" ","type":"Gigan.Knowledge.Knowledge v -> Bool"},{"name":"isNil","comment":" ","type":"Gigan.Knowledge.Knowledge v -> Bool"},{"name":"isNotForbidden","comment":" ","type":"Gigan.Knowledge.Knowledge v -> Bool"},{"name":"isNotKnown","comment":" ","type":"Gigan.Knowledge.Knowledge v -> Bool"},{"name":"isNotNil","comment":" ","type":"Gigan.Knowledge.Knowledge v -> Bool"},{"name":"isNotOperation","comment":" ","type":"Gigan.Knowledge.Knowledge v -> Bool"},{"name":"isNotPending","comment":" ","type":"Gigan.Knowledge.Knowledge v -> Bool"},{"name":"isNotUndecided","comment":" ","type":"Gigan.Knowledge.Knowledge v -> Bool"},{"name":"isNotUnknown","comment":" ","type":"Gigan.Knowledge.Knowledge v -> Bool"},{"name":"isNotVoid","comment":" ","type":"Gigan.Knowledge.Knowledge v -> Bool"},{"name":"isOperation","comment":" ","type":"Gigan.Knowledge.Knowledge v -> Bool"},{"name":"isPending","comment":" ","type":"Gigan.Knowledge.Knowledge v -> Bool"},{"name":"isUndecided","comment":" ","type":"Gigan.Knowledge.Knowledge v -> Bool"},{"name":"isUnknown","comment":" ","type":"Gigan.Knowledge.Knowledge v -> Bool"},{"name":"isVoid","comment":" ","type":"Gigan.Knowledge.Knowledge v -> Bool"},{"name":"knowledgeDo","comment":" ","type":"(Gigan.Knowledge.Knowledge v -> Gigan.Knowledge.Knowledge v) -> comparable -> Gigan.Knowledge.Knowledge v -> Gigan.Knowledge.Knowledge v"},{"name":"knowledgeIntegrate","comment":" ","type":"Gigan.Knowledge.RemoteConfig v -> Gigan.Knowledge.Knowledge v -> Gigan.Knowledge.Knowledge v"},{"name":"knowledgeOf","comment":" ","type":"v -> Gigan.Knowledge.Knowledge v"},{"name":"knowledgeQuery","comment":" ","type":"Gigan.Knowledge.RemoteConfig v -> Gigan.Knowledge.Knowledge v -> Maybe.Maybe (Gigan.Knowledge.QueryTask never)"},{"name":"knowledgeUpdate","comment":" ","type":"Gigan.Knowledge.KnowledgeBaseDelta comparable v -> Gigan.Knowledge.Knowledge v -> Gigan.Knowledge.Knowledge v"},{"name":"maybeKnownNow","comment":" If a knowledge is known, then give Just it's value, otherwise Nothing. ","type":"Gigan.Knowledge.Knowledge v' -> Maybe.Maybe v'"},{"name":"maybeOr","comment":" ","type":"Gigan.Knowledge.Knowledge v -> Maybe.Maybe v -> Gigan.Knowledge.Knowledge v"},{"name":"otherwise","comment":" Preferred shorthand for reduceNotKnownNowTo ","type":"v' -> Gigan.Knowledge.Knowledge v' -> v'"},{"name":"pendingKnowledge","comment":" ","type":"Gigan.Knowledge.Knowledge v"},{"name":"record","comment":" ","type":"Signal.Address (Gigan.Knowledge.KnowledgeBaseDelta comparable v) -> userrecord -> Gigan.Knowledge.KnowledgeRecord userrecord comparable v"},{"name":"recordAt","comment":" ","type":"(userrecord -> Gigan.Knowledge.Knowledge v) -> Gigan.Knowledge.KnowledgeRecord userrecord comparable v -> Gigan.Knowledge.Knowledge v"},{"name":"recordBinding","comment":" ","type":"Gigan.Knowledge.KnowledgeRecord userrecord comparable v -> Gigan.Knowledge.KnowledgeBase comparable v"},{"name":"recordContent","comment":" ","type":"Gigan.Knowledge.KnowledgeRecord userrecord comparable v -> userrecord"},{"name":"recordDo","comment":" ","type":"(Gigan.Knowledge.Knowledge v -> Gigan.Knowledge.Knowledge v) -> comparable -> Gigan.Knowledge.KnowledgeRecord userrecord comparable v -> Gigan.Knowledge.KnowledgeRecord userrecord comparable v"},{"name":"recordErrorHandler","comment":" ","type":"(Gigan.Error.Error -> Gigan.Knowledge.Knowledge v) -> Gigan.Knowledge.KnowledgeRecord userrecord comparable v -> Gigan.Knowledge.KnowledgeRecord userrecord comparable v"},{"name":"recordField","comment":" ","type":"(Gigan.Knowledge.Knowledge v -> userrecord -> userrecord) -> (userrecord -> Gigan.Knowledge.Knowledge v) -> comparable -> Gigan.Knowledge.KnowledgeRecord userrecord comparable v -> Gigan.Knowledge.KnowledgeRecord userrecord comparable v"},{"name":"recordIntegrate","comment":" ","type":"Gigan.Knowledge.KnowledgeRecord userrecord comparable v -> Gigan.Knowledge.KnowledgeRecord userrecord comparable v"},{"name":"recordQuery","comment":" ","type":"Gigan.Knowledge.KnowledgeRecord userrecord comparable v -> Maybe.Maybe (Gigan.Knowledge.QueryTask never)"},{"name":"recordUpdate","comment":" ","type":"Gigan.Knowledge.KnowledgeBaseDelta comparable v -> Gigan.Knowledge.KnowledgeRecord userrecord comparable v -> Gigan.Knowledge.KnowledgeRecord userrecord comparable v"},{"name":"reduceNotKnownNowTo","comment":" This is the special reduction we use to collapse away the Knowledge type, determining a final\nvalue to work with. ","type":"v' -> Gigan.Knowledge.Knowledge v' -> v'"},{"name":"remoteConfig","comment":" Specifies an RemoteConfig with which to close off an remote operation by sending it's results or an\nerror describing it's failure to the given Signal.Address (Knowledge v). ","type":"Signal.Address (Gigan.Knowledge.Knowledge v) -> Gigan.Knowledge.RemoteConfig v"},{"name":"remoteErrorConfig","comment":" Adds an optional special error handler for resolving totally unexpected errors. A \"final\" error\nhandler should be provided such that any errors not trapped by a decideBy application still\ngracefully recover. By default, a valid knowledge is produced from any error by promoting that\nError to Undecided. ","type":"(Gigan.Error.Error -> Gigan.Knowledge.Knowledge v) -> Gigan.Knowledge.RemoteConfig v -> Gigan.Knowledge.RemoteConfig v"},{"name":"resultOr","comment":" ","type":"(Gigan.Error.Error -> Gigan.Knowledge.Knowledge v) -> Result.Result Gigan.Error.Error v -> Gigan.Knowledge.Knowledge v"},{"name":"therefore","comment":" transform the value itself, if known, producing a knowledge of some new value type value'.\ntherefores are composed on to the results of remote operations if they represent known knowledge or\nfurther operations to attempt. This allows us to compose async processing stages before knowledge\nis finally reduced to a displayed or usable result as deeply and interchangably as we want to,\nprovided that we always use \"therefore\" _first_ to lift the knowledge type out before listing\na sequence of simple or contingent reductions. ","type":"(v -> v') -> Gigan.Knowledge.Knowledge v -> Gigan.Knowledge.Knowledge v'"},{"name":"undecidedKnowledge","comment":" ","type":"Gigan.Error.Error -> Gigan.Knowledge.Knowledge v"},{"name":"unknownKnowledge","comment":" ","type":"Gigan.Knowledge.Knowledge v"},{"name":"voidKnowledge","comment":" ","type":"Gigan.Knowledge.Knowledge v"},{"name":"within","comment":" This is for nesting operations on knowledge bases. For example:\n\n    -- this'll write something at the patch foo.bar if \"bar\" is void.\n    baseDo (within <| baseDo (inquireIf isVoid myBarWriter) \"bar\") \"foo\" myBase\n\nThis code will work on a knowledge base of base knowledges, so that's a nested record. The active\nrecord pattern can be approximated like this, and I've found it extremely handy.\n\n","type":"(sub -> sub) -> Gigan.Knowledge.Knowledge sub -> Gigan.Knowledge.Knowledge sub"}],"generated-with-elm-version":"0.16.0"},{"name":"Gigan.Stem","comment":" This module builds a more usable state machine snapshot with the Elm Architecture in mind on\ntop of the Gigan Core.\n\n# Definition\n@docs Stem\n\n# Constructor\n@docs stem\n\n# Get and Set the Model\n@docs stemModel, stemReplaceModel\n\n# Using Stems\n@docs stemDispatch, stemDispatchAs, stemDispatchment, stemDispatchmentAs, stemPresent, stemPresentAs, stemStage, stemStageAs, stemUpdate, stemIntegrate\n\n# Get and Set the Model of Maybe Stems\n@docs maybeStemModel, maybeStemReplaceModel\n\n# Using Maybe Stems\n@docs maybeStemDispatch, maybeStemDispatchAs, maybeStemDispatchment, maybeStemDispatchmentAs, maybeStemPresent, maybeStemPresentAs, maybeStemStage, maybeStemStageAs, maybeStemUpdate, maybeStemIntegrate\n\n","aliases":[{"name":"Stem","comment":" A Stem is an instantaneous description of some model associated with an OrbiterInput (see Core)\nthat specifies how it should be updated, staged and presented. ","args":["a","b","c","bad"],"type":"{ input : Gigan.Core.OrbiterInput a b c bad , state : Gigan.Core.OrbiterSnapshot a b bad }"}],"types":[],"values":[{"name":"maybeStemDispatch","comment":" ","type":"Maybe.Maybe (Gigan.Stem.Stem a b c bad) -> Maybe.Maybe ( Gigan.Stem.Stem a b c bad, Gigan.Core.TaskDispatchment bad a )"},{"name":"maybeStemDispatchAs","comment":" ","type":"(List a -> List a') -> Maybe.Maybe (Gigan.Stem.Stem a b c bad) -> Maybe.Maybe ( Gigan.Stem.Stem a b c bad, Gigan.Core.TaskDispatchment bad a' )"},{"name":"maybeStemDispatchment","comment":" ","type":"Maybe.Maybe (Gigan.Stem.Stem a b c bad) -> Gigan.Core.TaskDispatchment bad a"},{"name":"maybeStemDispatchmentAs","comment":" ","type":"(List a -> List a') -> Maybe.Maybe (Gigan.Stem.Stem a b c bad) -> Gigan.Core.TaskDispatchment bad a'"},{"name":"maybeStemIntegrate","comment":" ","type":"Maybe.Maybe (Gigan.Stem.Stem a b c bad) -> Maybe.Maybe (Gigan.Stem.Stem a b c bad)"},{"name":"maybeStemModel","comment":" ","type":"Maybe.Maybe (Gigan.Stem.Stem a b c bad) -> Maybe.Maybe b"},{"name":"maybeStemPresent","comment":" ","type":"Signal.Address (List a) -> Time.Time -> Maybe.Maybe (Gigan.Stem.Stem a b c bad) -> Maybe.Maybe (Gigan.Core.ViewOutput a c bad)"},{"name":"maybeStemPresentAs","comment":" ","type":"(List a -> List a') -> Signal.Address (List a') -> Time.Time -> Maybe.Maybe (Gigan.Stem.Stem a b c bad) -> Maybe.Maybe (Gigan.Core.ViewOutput a' c bad)"},{"name":"maybeStemReplaceModel","comment":" ","type":"b -> Maybe.Maybe (Gigan.Stem.Stem a b c bad) -> Maybe.Maybe (Gigan.Stem.Stem a b c bad)"},{"name":"maybeStemStage","comment":" ","type":"Signal.Address (List a) -> Time.Time -> Maybe.Maybe (Gigan.Stem.Stem a b c bad) -> Maybe.Maybe (Gigan.Stem.Stem a b c bad)"},{"name":"maybeStemStageAs","comment":" ","type":"(List a -> List a') -> Signal.Address (List a') -> Time.Time -> Maybe.Maybe (Gigan.Stem.Stem a b c bad) -> Maybe.Maybe (Gigan.Stem.Stem a b c bad)"},{"name":"maybeStemUpdate","comment":" ","type":"List a -> Time.Time -> Maybe.Maybe (Gigan.Stem.Stem a b c bad) -> Maybe.Maybe (Gigan.Stem.Stem a b c bad)"},{"name":"stem","comment":" Create a stem from an OrbiterInput ","type":"Gigan.Core.OrbiterInput a b c bad -> Gigan.Stem.Stem a b c bad"},{"name":"stemDispatch","comment":" Dispatch the tasks of a Stem. This function is in the depreciated family of `stemDispatch*`\nfunctions. Use `stemDispatchment*` and `stemIntegrate` instead. ","type":"Gigan.Stem.Stem a b c bad -> ( Gigan.Stem.Stem a b c bad, Gigan.Core.TaskDispatchment bad a )"},{"name":"stemDispatchAs","comment":" Dispatch the tasks of a Stem using some transducer to translate the action list. This function\nis in the depreciated family of `stemDispatch*` functions. Use `stemDispatchment*` and\n`stemIntegrate` instead. ","type":"(List a -> List a') -> Gigan.Stem.Stem a b c bad -> ( Gigan.Stem.Stem a b c bad, Gigan.Core.TaskDispatchment bad a' )"},{"name":"stemDispatchment","comment":" Get the currently waiting dispatchment. ","type":"Gigan.Stem.Stem a b c bad -> Gigan.Core.TaskDispatchment bad a"},{"name":"stemDispatchmentAs","comment":" Get the currently waiting task dispatchment, but apply some action type transformation. ","type":"(List a -> List a') -> Gigan.Stem.Stem a b c bad -> Gigan.Core.TaskDispatchment bad a'"},{"name":"stemIntegrate","comment":" Remove the currently waiting task dispatchment. This should be done only after retrieving any\npossibly waiting dispatchment. ","type":"Gigan.Stem.Stem a b c bad -> Gigan.Stem.Stem a b c bad"},{"name":"stemModel","comment":" Get the model of a stem. ","type":"Gigan.Stem.Stem a b c bad -> b"},{"name":"stemPresent","comment":" Run the present function from the configured OrbiterInput of the Stem on the Stem's current model to produce a ViewOutput, which includes the an element of the Stem's view type, and a TaskDispatchment for any desired asynchronous tasks.\nThis takes an address for actions to be sent to, the current time, and the Stem. ","type":"Signal.Address (List a) -> Time.Time -> Gigan.Stem.Stem a b c bad -> Gigan.Core.ViewOutput a c bad"},{"name":"stemPresentAs","comment":" Same as stemPresent, but with a transformation to apply to action lists before they are sent to the address. ","type":"(List a -> List a') -> Signal.Address (List a') -> Time.Time -> Gigan.Stem.Stem a b c bad -> Gigan.Core.ViewOutput a' c bad"},{"name":"stemReplaceModel","comment":" Create a stem with a different model from a replacement model and an original stem. ","type":"b -> Gigan.Stem.Stem a b c bad -> Gigan.Stem.Stem a b c bad"},{"name":"stemStage","comment":" Run the update function from the configured OrbiterInput of the Stem on the Stem's current model to produce a new model and dispatch any asynchronous tasks desired.\nThis takes an address for actions to be sent to, the current time, and the Stem. ","type":"Signal.Address (List a) -> Time.Time -> Gigan.Stem.Stem a b c bad -> Gigan.Stem.Stem a b c bad"},{"name":"stemStageAs","comment":" Same as stemStage, but with a transformation to apply to action lists before they are sent to the address. ","type":"(List a -> List a') -> Signal.Address (List a') -> Time.Time -> Gigan.Stem.Stem a b c bad -> Gigan.Stem.Stem a b c bad"},{"name":"stemUpdate","comment":" Run the update function from the configured OrbiterInput of the Stem on the Stem's current model to produce a new model and dispatch any asynchronous tasks desired.\nThis takes a list of actions, the current time, and the Stem. ","type":"List a -> Time.Time -> Gigan.Stem.Stem a b c bad -> Gigan.Stem.Stem a b c bad"}],"generated-with-elm-version":"0.16.0"},{"name":"Gigan.Error","comment":" This module has is the internal error type for Gigan.\n\n# Definitions\n@docs Error, ErrorType(OtherError, DecoderError, RemoteError, UserError)\n\n# Constructor\n@docs reportError\n\n","aliases":[{"name":"Error","comment":" Error record. ","args":[],"type":"{ error : Gigan.Error.ErrorType, desc : String }"}],"types":[{"name":"ErrorType","comment":" Type of error that occurred in Gigan. ","args":[],"cases":[["OtherError",[]],["DecoderError",[]],["RemoteError",["Json.Encode.Value"]],["UserError",["Json.Encode.Value"]]]}],"values":[{"name":"reportError","comment":" Report an error. Given an ErrorType and a String describing what went wrong humanly, create\nan error record.  ","type":"Gigan.Error.ErrorType -> String -> Gigan.Error.Error"}],"generated-with-elm-version":"0.16.0"},{"name":"Gigan.Layout","comment":" A very nice ruler snapping system for layouts. Actual documentation underway.\n\n# Definitions\n@docs Axis, Bounds, Group, Item, Rule\n\n# Ruler Guide Manipulation\n@docs adjustedRule, horizontalRule, horizontalRuleBetween, horizontalRuleCentered, itemHorizontalRule, itemRule, itemVerticalRule, ruleBetween, ruleCenter, snapToRule, towardsRule, towardsRuleRelative, verticalRule, verticalRuleBetween, verticalRuleCentered\n\n# Grouping and Group Operations\n@docs appendGroup, group, groupAt, groupAtBefore, groupElements, groupFromArray, groupFromDict, groupSize, prependGroup, computed, butBefore, butBeforeAt, butBeforeSlice, thenDo, thenDoAt, thenDoSlice, flatten, flattenOutTo, flattenTo, flattenWithin, flattenWithinOutTo\n\n# Group Spacing and Distribution.\n@docs spacedBetween, spacedBy, regularly, vertically, horizontally\n\n# Bounds Definitions\n@docs defBounds, autoBounds, boundsHeight, boundsLower, boundsSize, boundsUpper, boundsWidth, clampedBounds, clampedInnerBounds, clampedOuterBounds\n\n# Item Grabs\n@docs grabItem, grabItemRelative, grabItemRelativeX, grabItemRelativeY, grabItemX, grabItemY\n\n# Item Metrics\n@docs itemBounds, itemWidth, itemHeight, itemSize\n\n# Item Placement\n@docs lerpOf, move, moveX, moveY, place, placeX, placeY\n\n# Create and Display Items\n@docs emptyItem, toItem, fromItem\n\n","aliases":[{"name":"Item","comment":" An item, which represents an Elm Element with a position and a handle. ","args":[],"type":"{ elem : Graphics.Element.Element , x : Int , u : Int , y : Int , v : Int }"}],"types":[{"name":"Axis","comment":" An axis along which to evenly distribute by spacing or handle position. ","args":[],"cases":[]},{"name":"Bounds","comment":" A bounding box, given as a minimum and a maximum. ","args":[],"cases":[]},{"name":"Group","comment":" Group is an opaque type that represents a grouped set of items with a pending set of transformations. ","args":[],"cases":[]},{"name":"Rule","comment":" A guide ruler defined as either a vertical or a horizontal axis aligned line. ","args":[],"cases":[]}],"values":[{"name":"adjustedRule","comment":" Adjust a horizontal or vertical ruler. ","type":"(Int -> Gigan.Layout.Rule) -> Int -> Gigan.Layout.Rule -> Gigan.Layout.Rule"},{"name":"appendGroup","comment":" Append two groups, resulting a group containing the elements from `grp` first and the\nelements of `grp'` second. ","type":"Gigan.Layout.Group -> Gigan.Layout.Group -> Gigan.Layout.Group"},{"name":"autoBounds","comment":" Automatic bounds. ","type":"Gigan.Layout.Bounds"},{"name":"boundsHeight","comment":" Get the width of a bounding box, defined as boundsSize >> snd ","type":"Gigan.Layout.Bounds -> Int"},{"name":"boundsLower","comment":" Get the minimum bound if a minimum bound is defined. ","type":"Gigan.Layout.Bounds -> Maybe.Maybe ( Int, Int )"},{"name":"boundsSize","comment":" Get the size of a bounding box if both maximum and minimum bounds are defined, otherwise (0, 0). ","type":"Gigan.Layout.Bounds -> ( Int, Int )"},{"name":"boundsUpper","comment":" Get the maximum bound if a maximum bound is defined. ","type":"Gigan.Layout.Bounds -> Maybe.Maybe ( Int, Int )"},{"name":"boundsWidth","comment":" Get the width of a bounding box, defined as boundsSize >> fst ","type":"Gigan.Layout.Bounds -> Int"},{"name":"butBefore","comment":" Apply some transformation to every item in the group before the pending transformations. ","type":"(Gigan.Layout.Item -> Gigan.Layout.Item) -> Gigan.Layout.Group -> Gigan.Layout.Group"},{"name":"butBeforeAt","comment":" Apply some transformation to the item at a particular index in the group before the pending transformations. ","type":"Int -> (Gigan.Layout.Item -> Gigan.Layout.Item) -> Gigan.Layout.Group -> Gigan.Layout.Group"},{"name":"butBeforeSlice","comment":" Apply some transformation to the items in a particular slice of the group before the pending transformations. ","type":"Int -> Int -> (Gigan.Layout.Item -> Gigan.Layout.Item) -> Gigan.Layout.Group -> Gigan.Layout.Group"},{"name":"clampedBounds","comment":" Clamp a bounding box to some inner bounding box and some outer bounding box. Either the inner\nor the outer bounding box may be autoBounds, so this may also only clamp an inner or an outer limit,\nor neither. ","type":"Gigan.Layout.Bounds -> Gigan.Layout.Bounds -> Gigan.Layout.Bounds -> Gigan.Layout.Bounds"},{"name":"clampedInnerBounds","comment":" clampedInnerBounds myBounds = clampedBounds myBounds autoBounds ","type":"Gigan.Layout.Bounds -> Gigan.Layout.Bounds -> Gigan.Layout.Bounds"},{"name":"clampedOuterBounds","comment":" clampedOuterBounds myBounds = clampedBounds autoBounds myBounds ","type":"Gigan.Layout.Bounds -> Gigan.Layout.Bounds -> Gigan.Layout.Bounds"},{"name":"computed","comment":" Run any pending transformations on all group items. For the most part, this can be avoided, but it should be\ndone if you are planning to get a lot of items back from the group transformed, or else the work of applying the\npending group transforms will be done at least twice, once when you retrieve the item using groupAt and once when\nyou flatten the group to produce an item. ","type":"Gigan.Layout.Group -> Gigan.Layout.Group"},{"name":"defBounds","comment":" Define a definite bounding box. ","type":"Int -> Int -> Int -> Int -> Gigan.Layout.Bounds"},{"name":"emptyItem","comment":" An empty layout item. ","type":"Gigan.Layout.Item"},{"name":"flatten","comment":" Flatten a group using automatic bounds for the inner and outer bounds. This will produce the\ntightest bounding box possible around the target, and place the handle at (0, 0) relative to the resulting\nbounding box. This can result in the handle being placed outside of the group, but this can be desirable for\npositioning. For example, I may want to grab something at (-5, -5), so I can position it's top left\ncorner relative to some outer box with (5, 5) padding. ","type":"Gigan.Layout.Group -> Gigan.Layout.Item"},{"name":"flattenOutTo","comment":" Flatten a group using only an inner bound, which is equivalent to\n\n    flattenWithinOutTo outer autoBounds\n","type":"Gigan.Layout.Bounds -> Gigan.Layout.Group -> Gigan.Layout.Item"},{"name":"flattenTo","comment":" Flatten a group using an exact bound. If this is specified to be autoBounds, then the following\nequivalency holds:\n\n    flattenTo autoBounds group == flatten group\n\nOtherwise, the items in the group are positioned in the resulting item relative to the top left corner of the bounds and\nthe resulting item shall have the exact size of the given bounds. ","type":"Gigan.Layout.Bounds -> Gigan.Layout.Group -> Gigan.Layout.Item"},{"name":"flattenWithin","comment":" Flatten a group using only an outer bound, which is equivalent to\n\n    flattenWithinOutTo autoBounds outer\n","type":"Gigan.Layout.Bounds -> Gigan.Layout.Group -> Gigan.Layout.Item"},{"name":"flattenWithinOutTo","comment":" Flatten a group using an inner and an outer bound to clamp the size of the resulting item.\n","type":"Gigan.Layout.Bounds -> Gigan.Layout.Bounds -> Gigan.Layout.Group -> Gigan.Layout.Item"},{"name":"fromItem","comment":" Get the Graphics Element from an Item. Note that this will get the original Element back,\nunaffected by any positioning done using placement and group operations. To produce Graphics\nElements with finished layouts, refer to the flatten functions. ","type":"Gigan.Layout.Item -> Graphics.Element.Element"},{"name":"grabItem","comment":" Grab an item, producing a handle. This defines a point on the item called the \"handle\" that is\nplaced exactly at item's coordinates. If I say\n\n  grabItem 0 0\n\nthen that would grab the top left corner. u and v and given as window coordinates relative to the\ntop left corner of the item. ","type":"Int -> Int -> Gigan.Layout.Item -> Gigan.Layout.Item"},{"name":"grabItemRelative","comment":" Grab an item in normalized coordinates relative to it's size. This means that (1, 1) is the\nbottom right corner, and (0, 0) is the top left corner. ","type":"Float -> Float -> Gigan.Layout.Item -> Gigan.Layout.Item"},{"name":"grabItemRelativeX","comment":" Grab an item by it's x coordinate relative to the item's size. ","type":"Float -> Gigan.Layout.Item -> Gigan.Layout.Item"},{"name":"grabItemRelativeY","comment":" Grab an item by it's y coordinate relative to the item's size. ","type":"Float -> Gigan.Layout.Item -> Gigan.Layout.Item"},{"name":"grabItemX","comment":" Grab an item by it's x coordinate. ","type":"Int -> Gigan.Layout.Item -> Gigan.Layout.Item"},{"name":"grabItemY","comment":" Grab an item by it's y coordinate. ","type":"Int -> Gigan.Layout.Item -> Gigan.Layout.Item"},{"name":"group","comment":" Create an item group from a list. ","type":"List Gigan.Layout.Item -> Gigan.Layout.Group"},{"name":"groupAt","comment":" Retrieve the item at a given index in the group, or Nothing if the index is out of bounds. If\nthere are waiting transformations, a copy of the item with those transformations applied will be\ngiven. ","type":"Int -> Gigan.Layout.Group -> Maybe.Maybe Gigan.Layout.Item"},{"name":"groupAtBefore","comment":" Retrieve the item at a given index in the group, or Nothing if the index is out of bounds. The\nitem will be retrieved in it's original state without any pending group transformations applied. ","type":"Int -> Gigan.Layout.Group -> Maybe.Maybe Gigan.Layout.Item"},{"name":"groupElements","comment":" This is a shortcut for grouping graphics elements, which is very useful for compositing graphics\nelements such as images directly for layering effects. ","type":"List Graphics.Element.Element -> Gigan.Layout.Group"},{"name":"groupFromArray","comment":" Create an item group from an array. ","type":"Array.Array Gigan.Layout.Item -> Gigan.Layout.Group"},{"name":"groupFromDict","comment":" Create an item group from a dictionary. ","type":"Dict.Dict comparable Gigan.Layout.Item -> Gigan.Layout.Group"},{"name":"groupSize","comment":" Get the size of the group. ","type":"Gigan.Layout.Group -> Int"},{"name":"horizontalRule","comment":" Create a new horizontal ruler at the given y coordinate. ","type":"Int -> Gigan.Layout.Rule"},{"name":"horizontalRuleBetween","comment":" Shorthand for ruleBetween horizontalRule ","type":"Int -> Int -> Float -> Gigan.Layout.Rule"},{"name":"horizontalRuleCentered","comment":" Shorthand for ruleCenter horizontalRule ","type":"Int -> Int -> Gigan.Layout.Rule"},{"name":"horizontally","comment":" Do a distribution horizontally. ","type":"Gigan.Layout.Axis"},{"name":"itemBounds","comment":" Get the resultant bounding box of an item, given it's placement and handle. ","type":"Gigan.Layout.Item -> Gigan.Layout.Bounds"},{"name":"itemHeight","comment":" Get the height of an item. ","type":"Gigan.Layout.Item -> Int"},{"name":"itemHorizontalRule","comment":" Create a horizontal ruler aligned with an item. ","type":"Gigan.Layout.Item -> Gigan.Layout.Rule"},{"name":"itemRule","comment":" Create a vertical or a horizontal ruler aligned with an item. ","type":"(Int -> Gigan.Layout.Rule) -> Gigan.Layout.Item -> Gigan.Layout.Rule"},{"name":"itemSize","comment":" Get the size of an Item. ","type":"Gigan.Layout.Item -> ( Int, Int )"},{"name":"itemVerticalRule","comment":" Create a vertical ruler aligned with an item. ","type":"Gigan.Layout.Item -> Gigan.Layout.Rule"},{"name":"itemWidth","comment":" Get the width of an item. ","type":"Gigan.Layout.Item -> Int"},{"name":"lerpOf","comment":" Modify any of the item manipulation primitives by linearly interpolating the handle and coordinates\nbetween the current and output values. This provides the basic building block for transitional animations.\nEasing functions could quite easily be implemented on top of this. ","type":"(Gigan.Layout.Item -> Gigan.Layout.Item) -> Float -> Gigan.Layout.Item -> Gigan.Layout.Item"},{"name":"move","comment":" Move an item. ","type":"Int -> Int -> Gigan.Layout.Item -> Gigan.Layout.Item"},{"name":"moveX","comment":" Move an item horizontally. ","type":"Int -> Gigan.Layout.Item -> Gigan.Layout.Item"},{"name":"moveY","comment":" Move an item vertically. ","type":"Int -> Gigan.Layout.Item -> Gigan.Layout.Item"},{"name":"place","comment":" Place the handle of an item at these coordinates. ","type":"Int -> Int -> Gigan.Layout.Item -> Gigan.Layout.Item"},{"name":"placeX","comment":" Place the handle of an item at this x coordinate. ","type":"Int -> Gigan.Layout.Item -> Gigan.Layout.Item"},{"name":"placeY","comment":" Place the handle of an item at this y coordinate. ","type":"Int -> Gigan.Layout.Item -> Gigan.Layout.Item"},{"name":"prependGroup","comment":" Prepend a group before another, resulting a group containing the elements from `grp` second and\nthe elements of `grp'` first. ","type":"Gigan.Layout.Group -> Gigan.Layout.Group -> Gigan.Layout.Group"},{"name":"regularly","comment":" Distribute the items in the group along some Axis given a starting coordinate and an ending\ncoordinate, such that the handles of the items are evenly distributed between the starting and the\nending coordinates. The height or width of this vertical or horizontal distribution is dependent on\nthe positioning of the handles on the items, and the coordinate not effected by the distribution is\nleft in place. ","type":"Gigan.Layout.Axis -> Int -> Int -> Gigan.Layout.Group -> Gigan.Layout.Group"},{"name":"ruleBetween","comment":" Given a ruler direction (verticalRule or horizontalRule), a lower and an upper bound, and some\nfloat t between 0 and 1, linearly interpolate between the lower and upper bound by t. ","type":"(Int -> Gigan.Layout.Rule) -> Int -> Int -> Float -> Gigan.Layout.Rule"},{"name":"ruleCenter","comment":" Given a ruler direction (verticalRule or horizontalRule), a lower bound, and an upper bound,\ncenter a ruler between the lower and the upper bound. The following equivalencies hold:\n\n    ruleCenter verticalRule x0 x1 == ruleBetween verticalRule x0 x1 0.5\n    ruleCenter horizontalRule y0 y1 == ruleBetween horizontalRule y0 y1 0.5\n\n","type":"(Int -> Gigan.Layout.Rule) -> Int -> Int -> Gigan.Layout.Rule"},{"name":"snapToRule","comment":" Snap an item's handle to a vertical or horizontal ruler. ","type":"Gigan.Layout.Rule -> Gigan.Layout.Item -> Gigan.Layout.Item"},{"name":"spacedBetween","comment":" Distribute the items in the group along some Axis given a starting coordinate and an ending\ncoordinate, such that the spaces between all of the items are even, resulting in a justified layout.\nVertical distribution is done top to bottom, horizontal distribution is done left to right.\n\nThe height or width of this vertical or horizontal distribution is\n\n    to - from\n\nand the coordinate not effected by the distribution is left in place.\n","type":"Gigan.Layout.Axis -> Int -> Int -> Gigan.Layout.Group -> Gigan.Layout.Group"},{"name":"spacedBy","comment":" Distribute the items in the group along some Axis given a starting coordinate and spacing given\nin window coordinates, resulting in an evenly spaced horizontal or vertical distribution. Vertical\ndistribution is done top to bottom, horizontal distribution is done left to right.\n\nThe height or width of this vertical or horizontal distribution is\n\n    from + siz * (n - 1) + (sum itemHeight items)\n\nand the coordinate not effected by the distribution is left in place.\n\n","type":"Gigan.Layout.Axis -> Int -> Int -> Gigan.Layout.Group -> Gigan.Layout.Group"},{"name":"thenDo","comment":" Apply some transformation to every item in the group after the pending transformations. ","type":"(Gigan.Layout.Item -> Gigan.Layout.Item) -> Gigan.Layout.Group -> Gigan.Layout.Group"},{"name":"thenDoAt","comment":" Apply some transformation to the item at a particular index in the group after the pending transformations. ","type":"Int -> (Gigan.Layout.Item -> Gigan.Layout.Item) -> Gigan.Layout.Group -> Gigan.Layout.Group"},{"name":"thenDoSlice","comment":" Apply some transformation to the items in a particular slice of the group after the pending transformations. ","type":"Int -> Int -> (Gigan.Layout.Item -> Gigan.Layout.Item) -> Gigan.Layout.Group -> Gigan.Layout.Group"},{"name":"toItem","comment":" Convert a Graphics Element to an Item ","type":"Graphics.Element.Element -> Gigan.Layout.Item"},{"name":"towardsRule","comment":" Move an item's handle toward a vertical or horizontal ruler by some constant amount. ","type":"Gigan.Layout.Rule -> Int -> Gigan.Layout.Item -> Gigan.Layout.Item"},{"name":"towardsRuleRelative","comment":" Move an item's handle toward a vertical or horizontal ruler by some factor t  ","type":"Gigan.Layout.Rule -> Float -> Gigan.Layout.Item -> Gigan.Layout.Item"},{"name":"verticalRule","comment":" Create a new vertical ruler at the given x coordinate. ","type":"Int -> Gigan.Layout.Rule"},{"name":"verticalRuleBetween","comment":" Shorthand for ruleBetween verticalRule ","type":"Int -> Int -> Float -> Gigan.Layout.Rule"},{"name":"verticalRuleCentered","comment":" Shorthand for ruleCenter verticalRule ","type":"Int -> Int -> Gigan.Layout.Rule"},{"name":"vertically","comment":" Do a distribution vertically. ","type":"Gigan.Layout.Axis"}],"generated-with-elm-version":"0.16.0"},{"name":"Gigan.Core","comment":" This module is the main application scaffolding. Detailed documentation in progress.\n\n# Definitions\n@docs AgentStatus, ComputedResult, ComputedSuccess, FeedbackMethod, OrbiterInput, OrbiterOutput, OrbiterSnapshot, OrbiterTap, OrbiterTask, TaskDispatchment, UpdatedModel, ViewOutput\n\n# Define Orbiter Programs\n@docs defProgram, defProgram'\n\n# Run Orbiter Programs\n@docs orbits, orbitsWithWork, withInputs, withLazySequenceInputs, withSequenceInputs, sieve, (+-->)\n\n# UpdatedModel and ViewOutput Manipulation\n@docs updated, presented, withTasks, withDispatchment, withChildren, viewOutputTask\n\n# Dispatch Actions and Errors\n@docs actionTask, errorTask, computeTask, computedSuccess, noActions, nilTask\n\n# Intercept and Route Action and Error Outputs\n@docs successTap, errorTap, atomicSuccessTap, asyncSuccessTap, it'sErrorTap, itself, itselfDeferred, thisAddress, thisAddressDeferred, thisCustomAddress, thisCustomAddressDeferred, thisErrorTap, thisForwardTap, thisTap\n\n# Handling Tasks and TaskDispatchment\n@docs combineDispatchments, collapseTasks, dispatchTasks, dispatchmentHasWork, dispatchmentTask, promoteDispatchment\n\n# Manipulate Orbiter Snapshots\n@docs orbiterSnapshot, orbiterSnapshotAddDispatchment, orbiterSnapshotDispatch, orbiterSnapshotPresent, orbiterSnapshotStage, orbiterSnapshotUpdate, performCycle\n\n# Orbiter Task Agents\n@docs orbiterAgent, orbiterSuccessAgent, orbiterFailureAgent, orbiterBinaryAgent, orbiterBlindAgent, orbiterNilAgent, orbiterResultAgent, ignoreError\n\n","aliases":[{"name":"ComputedResult","comment":" todo doc ","args":["bad","a"],"type":"Result.Result bad (Gigan.Core.ComputedSuccess a)"},{"name":"ComputedSuccess","comment":" todo doc ","args":["a"],"type":"{ sequence : List a, method : Gigan.Core.FeedbackMethod }"},{"name":"OrbiterInput","comment":" todo doc ","args":["a","b","c","bad"],"type":"{ inputs : Lazy.List.LazyList (Signal.Signal (Lazy.List.LazyList a)) , model0 : b , present : Signal.Address (List a) -> Time.Time -> b -> Gigan.Core.ViewOutput a c bad , stage : Signal.Address (List a) -> Time.Time -> b -> Gigan.Core.UpdatedModel a b bad , update : a -> Time.Time -> b -> Gigan.Core.UpdatedModel a b bad }"},{"name":"OrbiterOutput","comment":" todo doc ","args":["a","b","c","bad"],"type":"{ view' : Signal.Signal c , model' : Signal.Signal b , now : Signal.Signal Time.Time , actions : Signal.Signal (List a) , tasks : Signal.Signal (Gigan.Core.OrbiterTask bad a) , address : Signal.Address (List a) , lazyAddress : Signal.Address (Lazy.List.LazyList a) }"},{"name":"OrbiterSnapshot","comment":" todo doc ","args":["a","b","bad"],"type":"{ model' : b, dispatchment : Gigan.Core.TaskDispatchment bad a }"},{"name":"OrbiterTap","comment":" todo doc ","args":["bad","a"],"type":"Signal.Address (List a) -> Gigan.Core.OrbiterTask bad a -> Gigan.Core.OrbiterTask bad a"},{"name":"OrbiterTask","comment":" todo doc ","args":["bad","a"],"type":"Task.Task bad (Gigan.Core.ComputedSuccess a)"},{"name":"TaskDispatchment","comment":" todo doc ","args":["bad","a"],"type":"{ taskExec : Lazy.List.LazyList (Gigan.Core.OrbiterTask bad a) }"},{"name":"UpdatedModel","comment":" todo doc ","args":["a","b","bad"],"type":"{ dispatchment : Gigan.Core.TaskDispatchment bad a, model' : b }"},{"name":"ViewOutput","comment":" todo doc ","args":["a","c","bad"],"type":"{ dispatchment : Gigan.Core.TaskDispatchment bad a, view' : c }"}],"types":[{"name":"AgentStatus","comment":" todo doc ","args":["bad","a"],"cases":[]},{"name":"FeedbackMethod","comment":" todo doc ","args":[],"cases":[]}],"values":[{"name":"+-->","comment":" todo doc ","type":"Gigan.Core.OrbiterOutput a b c bad -> (Gigan.Core.OrbiterOutput a b c bad -> Gigan.Core.OrbiterOutput a b c bad) -> Gigan.Core.OrbiterOutput a b c bad"},{"name":"actionTask","comment":" todo doc ","type":"List a -> Gigan.Core.OrbiterTask bad a"},{"name":"asyncSuccessTap","comment":" todo doc ","type":"Signal.Address (List a) -> Gigan.Core.OrbiterTask bad a -> Gigan.Core.OrbiterTask bad a"},{"name":"atomicSuccessTap","comment":" todo doc ","type":"Signal.Address (List a) -> Gigan.Core.OrbiterTask bad a -> Gigan.Core.OrbiterTask bad a"},{"name":"collapseTasks","comment":" todo doc ","type":"Gigan.Core.OrbiterTask bad a -> Gigan.Core.OrbiterTask bad a -> Gigan.Core.OrbiterTask bad a"},{"name":"combineDispatchments","comment":" todo doc ","type":"Gigan.Core.TaskDispatchment bad a -> Gigan.Core.TaskDispatchment bad a -> Gigan.Core.TaskDispatchment bad a"},{"name":"computeTask","comment":" todo doc ","type":"(data -> Gigan.Core.ComputedResult bad a) -> data -> Gigan.Core.OrbiterTask bad a"},{"name":"computedSuccess","comment":" todo doc ","type":"List a -> Gigan.Core.ComputedSuccess a"},{"name":"defProgram","comment":" todo doc ","type":"(Signal.Address (List a) -> Time.Time -> b -> Gigan.Core.ViewOutput a c bad) -> (a -> Time.Time -> b -> Gigan.Core.UpdatedModel a b bad) -> b -> Gigan.Core.OrbiterInput a b c bad"},{"name":"defProgram'","comment":" todo doc ","type":"(Signal.Address (List a) -> Time.Time -> b -> Gigan.Core.ViewOutput a c bad) -> (Signal.Address (List a) -> Time.Time -> b -> Gigan.Core.UpdatedModel a b bad) -> (a -> Time.Time -> b -> Gigan.Core.UpdatedModel a b bad) -> b -> Gigan.Core.OrbiterInput a b c bad"},{"name":"dispatchTasks","comment":" todo doc ","type":"List (Gigan.Core.OrbiterTask bad a) -> Gigan.Core.TaskDispatchment bad a"},{"name":"dispatchmentHasWork","comment":" todo doc ","type":"Gigan.Core.TaskDispatchment bad a -> Bool"},{"name":"dispatchmentTask","comment":" todo doc ","type":"Gigan.Core.TaskDispatchment bad a -> Gigan.Core.OrbiterTask bad a"},{"name":"errorTap","comment":" todo doc ","type":"Signal.Address (List a) -> (bad -> List a) -> Gigan.Core.OrbiterTask bad a -> Gigan.Core.OrbiterTask bad a"},{"name":"errorTask","comment":" todo doc ","type":"bad -> Gigan.Core.OrbiterTask bad a"},{"name":"ignoreError","comment":" todo doc ","type":"bad -> List a"},{"name":"it'sErrorTap","comment":" todo doc ","type":"(bad -> List a) -> Gigan.Core.OrbiterOutput a b c bad -> Gigan.Core.OrbiterOutput a b c bad"},{"name":"itself","comment":" todo doc ","type":"Gigan.Core.OrbiterOutput a b c bad -> Gigan.Core.OrbiterOutput a b c bad"},{"name":"itselfDeferred","comment":" todo doc ","type":"Gigan.Core.OrbiterOutput a b c bad -> Gigan.Core.OrbiterOutput a b c bad"},{"name":"nilTask","comment":" todo doc ","type":"Gigan.Core.OrbiterTask bad a"},{"name":"noActions","comment":" todo doc ","type":"List a"},{"name":"orbiterAgent","comment":" todo doc ","type":"(x -> Gigan.Core.AgentStatus bad a) -> (y -> Gigan.Core.AgentStatus bad a) -> Task.Task y x -> Gigan.Core.OrbiterTask bad a"},{"name":"orbiterBinaryAgent","comment":" todo doc ","type":"Gigan.Core.AgentStatus bad a -> Gigan.Core.AgentStatus bad a -> Task.Task y x -> Gigan.Core.OrbiterTask bad a"},{"name":"orbiterBlindAgent","comment":" todo doc ","type":"Gigan.Core.AgentStatus bad a -> Task.Task y x -> Gigan.Core.OrbiterTask bad a"},{"name":"orbiterFailureAgent","comment":" todo doc ","type":"Gigan.Core.AgentStatus bad a -> (y -> Gigan.Core.AgentStatus bad a) -> Task.Task y x -> Gigan.Core.OrbiterTask bad a"},{"name":"orbiterNilAgent","comment":" todo doc ","type":"Task.Task y x -> Gigan.Core.OrbiterTask bad a"},{"name":"orbiterResultAgent","comment":" todo doc ","type":"(Result.Result y x -> Gigan.Core.AgentStatus bad a) -> Task.Task y x -> Gigan.Core.OrbiterTask bad a"},{"name":"orbiterSnapshot","comment":" todo doc ","type":"b -> Gigan.Core.TaskDispatchment bad a -> Gigan.Core.OrbiterSnapshot a b bad"},{"name":"orbiterSnapshotAddDispatchment","comment":" todo doc ","type":"Gigan.Core.TaskDispatchment bad a -> Gigan.Core.OrbiterSnapshot a b bad -> Gigan.Core.OrbiterSnapshot a b bad"},{"name":"orbiterSnapshotDispatch","comment":" todo doc ","type":"Gigan.Core.OrbiterSnapshot a b bad -> ( Gigan.Core.OrbiterSnapshot a b bad , Gigan.Core.TaskDispatchment bad a )"},{"name":"orbiterSnapshotPresent","comment":" todo doc ","type":"{ k | present : Signal.Address (List a) -> Time.Time -> b -> Gigan.Core.ViewOutput a c bad } -> Signal.Address (List a) -> Time.Time -> Gigan.Core.OrbiterSnapshot a b bad -> Gigan.Core.ViewOutput a c bad"},{"name":"orbiterSnapshotStage","comment":" todo doc ","type":"{ k | stage : Signal.Address (List a) -> Time.Time -> b -> Gigan.Core.UpdatedModel a b bad } -> Signal.Address (List a) -> Time.Time -> Gigan.Core.OrbiterSnapshot a b bad -> Gigan.Core.OrbiterSnapshot a b bad"},{"name":"orbiterSnapshotUpdate","comment":" todo doc ","type":"{ k | update : a -> Time.Time -> b -> Gigan.Core.UpdatedModel a b bad } -> List a -> Time.Time -> Gigan.Core.OrbiterSnapshot a b bad -> Gigan.Core.OrbiterSnapshot a b bad"},{"name":"orbiterSuccessAgent","comment":" todo doc ","type":"(x -> Gigan.Core.AgentStatus bad a) -> Gigan.Core.AgentStatus bad a -> Task.Task y x -> Gigan.Core.OrbiterTask bad a"},{"name":"orbits","comment":" todo doc ","type":"Gigan.Core.OrbiterInput a b c bad -> Gigan.Core.OrbiterOutput a b c bad"},{"name":"orbitsWithWork","comment":" todo doc ","type":"Gigan.Core.OrbiterInput a b c bad -> Gigan.Core.OrbiterTask bad a -> Gigan.Core.OrbiterOutput a b c bad"},{"name":"performCycle","comment":" todo doc ","type":"Gigan.Core.OrbiterInput a b c bad -> Signal.Address (List a) -> ( Time.Time, List a ) -> ( Gigan.Core.OrbiterSnapshot a b bad , Gigan.Core.TaskDispatchment bad a ) -> ( Gigan.Core.OrbiterSnapshot a b bad , Gigan.Core.TaskDispatchment bad a )"},{"name":"presented","comment":" todo doc ","type":"c -> Gigan.Core.ViewOutput a c bad"},{"name":"promoteDispatchment","comment":" todo doc ","type":"(List a -> List a') -> Gigan.Core.TaskDispatchment bad a -> Gigan.Core.TaskDispatchment bad a'"},{"name":"sieve","comment":" todo doc ","type":"Gigan.Core.OrbiterOutput a b c bad -> Signal.Signal (Task.Task z ())"},{"name":"successTap","comment":" todo doc ","type":"Signal.Address (List a) -> Gigan.Core.OrbiterTask bad a -> Gigan.Core.OrbiterTask bad a"},{"name":"thisAddress","comment":" todo doc ","type":"Signal.Address (List a) -> Gigan.Core.OrbiterOutput a b c bad -> Gigan.Core.OrbiterOutput a b c bad"},{"name":"thisAddressDeferred","comment":" todo doc ","type":"Signal.Address (List a) -> Gigan.Core.OrbiterOutput a b c bad -> Gigan.Core.OrbiterOutput a b c bad"},{"name":"thisCustomAddress","comment":" todo doc ","type":"Signal.Address target -> (List a -> target) -> Gigan.Core.OrbiterOutput a b c bad -> Gigan.Core.OrbiterOutput a b c bad"},{"name":"thisCustomAddressDeferred","comment":" todo doc ","type":"Signal.Address target -> (List a -> target) -> Gigan.Core.OrbiterOutput a b c bad -> Gigan.Core.OrbiterOutput a b c bad"},{"name":"thisErrorTap","comment":" todo doc ","type":"Signal.Address (List a) -> (bad -> List a) -> Gigan.Core.OrbiterOutput a b c bad -> Gigan.Core.OrbiterOutput a b c bad"},{"name":"thisForwardTap","comment":" todo doc ","type":"Gigan.Core.OrbiterTap bad a -> Signal.Address target -> (List a -> target) -> Gigan.Core.OrbiterOutput a b c bad -> Gigan.Core.OrbiterOutput a b c bad"},{"name":"thisTap","comment":" todo doc ","type":"Gigan.Core.OrbiterTap bad a -> Signal.Address (List a) -> Gigan.Core.OrbiterOutput a b c bad -> Gigan.Core.OrbiterOutput a b c bad"},{"name":"updated","comment":" todo doc ","type":"b -> Gigan.Core.UpdatedModel a b bad"},{"name":"viewOutputTask","comment":" todo doc ","type":"Gigan.Core.ViewOutput a c bad -> Gigan.Core.OrbiterTask bad a"},{"name":"withChildren","comment":" todo doc ","type":"List { anything | dispatchment : Gigan.Core.TaskDispatchment bad a } -> { anything | dispatchment : Gigan.Core.TaskDispatchment bad a } -> { anything | dispatchment : Gigan.Core.TaskDispatchment bad a }"},{"name":"withDispatchment","comment":" todo doc ","type":"Gigan.Core.TaskDispatchment bad a -> { anything | dispatchment : Gigan.Core.TaskDispatchment bad a } -> { anything | dispatchment : Gigan.Core.TaskDispatchment bad a }"},{"name":"withInputs","comment":" todo doc ","type":"Gigan.Core.OrbiterInput a b c bad -> List (Signal.Signal a) -> Gigan.Core.OrbiterInput a b c bad"},{"name":"withLazySequenceInputs","comment":" todo doc ","type":"Gigan.Core.OrbiterInput a b c bad -> List (Signal.Signal (Lazy.List.LazyList a)) -> Gigan.Core.OrbiterInput a b c bad"},{"name":"withSequenceInputs","comment":" todo doc ","type":"Gigan.Core.OrbiterInput a b c bad -> List (Signal.Signal (List a)) -> Gigan.Core.OrbiterInput a b c bad"},{"name":"withTasks","comment":" todo doc ","type":"List (Gigan.Core.OrbiterTask bad a) -> { anything | dispatchment : Gigan.Core.TaskDispatchment bad a } -> { anything | dispatchment : Gigan.Core.TaskDispatchment bad a }"}],"generated-with-elm-version":"0.16.0"}]