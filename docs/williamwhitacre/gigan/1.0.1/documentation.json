[
  {
    "name": "Gigan.Stem",
    "comment": " This module builds a more usable state machine snapshot with the Elm Architecture in mind on\ntop of the Gigan Core.\n\n# Definition\n@docs Stem\n\n# Constructor\n@docs stem\n\n# Get and Set the Model\n@docs stemModel, stemReplaceModel\n\n# Using Stems\n@docs stemDispatch, stemDispatchAs, stemDispatchment, stemDispatchmentAs, stemPresent, stemPresentAs, stemStage, stemStageAs, stemUpdate, stemIntegrate\n\n# Get and Set the Model of Maybe Stems\n@docs maybeStemModel, maybeStemReplaceModel\n\n# Using Maybe Stems\n@docs maybeStemDispatch, maybeStemDispatchAs, maybeStemDispatchment, maybeStemDispatchmentAs, maybeStemPresent, maybeStemPresentAs, maybeStemStage, maybeStemStageAs, maybeStemUpdate, maybeStemIntegrate\n\n",
    "aliases": [
      {
        "name": "Stem",
        "comment": " A Stem is an instantaneous description of some model associated with an OrbiterInput (see Core)\nthat specifies how it should be updated, staged and presented. ",
        "args": [
          "a",
          "b",
          "c",
          "bad"
        ],
        "type": "{ input : Gigan.Core.OrbiterInput a b c bad , state : Gigan.Core.OrbiterSnapshot a b bad }"
      }
    ],
    "types": [],
    "values": [
      {
        "name": "maybeStemDispatch",
        "comment": " ",
        "type": "Maybe.Maybe (Gigan.Stem.Stem a b c bad) -> Maybe.Maybe ( Gigan.Stem.Stem a b c bad, Gigan.Core.TaskDispatchment bad a )"
      },
      {
        "name": "maybeStemDispatchAs",
        "comment": " ",
        "type": "(List a -> List a') -> Maybe.Maybe (Gigan.Stem.Stem a b c bad) -> Maybe.Maybe ( Gigan.Stem.Stem a b c bad, Gigan.Core.TaskDispatchment bad a' )"
      },
      {
        "name": "maybeStemDispatchment",
        "comment": " ",
        "type": "Maybe.Maybe (Gigan.Stem.Stem a b c bad) -> Gigan.Core.TaskDispatchment bad a"
      },
      {
        "name": "maybeStemDispatchmentAs",
        "comment": " ",
        "type": "(List a -> List a') -> Maybe.Maybe (Gigan.Stem.Stem a b c bad) -> Gigan.Core.TaskDispatchment bad a'"
      },
      {
        "name": "maybeStemIntegrate",
        "comment": " ",
        "type": "Maybe.Maybe (Gigan.Stem.Stem a b c bad) -> Maybe.Maybe (Gigan.Stem.Stem a b c bad)"
      },
      {
        "name": "maybeStemModel",
        "comment": " ",
        "type": "Maybe.Maybe (Gigan.Stem.Stem a b c bad) -> Maybe.Maybe b"
      },
      {
        "name": "maybeStemPresent",
        "comment": " ",
        "type": "Signal.Address (List a) -> Time.Time -> Maybe.Maybe (Gigan.Stem.Stem a b c bad) -> Maybe.Maybe (Gigan.Core.ViewOutput a c bad)"
      },
      {
        "name": "maybeStemPresentAs",
        "comment": " ",
        "type": "(List a -> List a') -> Signal.Address (List a') -> Time.Time -> Maybe.Maybe (Gigan.Stem.Stem a b c bad) -> Maybe.Maybe (Gigan.Core.ViewOutput a' c bad)"
      },
      {
        "name": "maybeStemReplaceModel",
        "comment": " ",
        "type": "b -> Maybe.Maybe (Gigan.Stem.Stem a b c bad) -> Maybe.Maybe (Gigan.Stem.Stem a b c bad)"
      },
      {
        "name": "maybeStemStage",
        "comment": " ",
        "type": "Signal.Address (List a) -> Time.Time -> Maybe.Maybe (Gigan.Stem.Stem a b c bad) -> Maybe.Maybe (Gigan.Stem.Stem a b c bad)"
      },
      {
        "name": "maybeStemStageAs",
        "comment": " ",
        "type": "(List a -> List a') -> Signal.Address (List a') -> Time.Time -> Maybe.Maybe (Gigan.Stem.Stem a b c bad) -> Maybe.Maybe (Gigan.Stem.Stem a b c bad)"
      },
      {
        "name": "maybeStemUpdate",
        "comment": " ",
        "type": "List a -> Time.Time -> Maybe.Maybe (Gigan.Stem.Stem a b c bad) -> Maybe.Maybe (Gigan.Stem.Stem a b c bad)"
      },
      {
        "name": "stem",
        "comment": " Create a stem from an OrbiterInput ",
        "type": "Gigan.Core.OrbiterInput a b c bad -> Gigan.Stem.Stem a b c bad"
      },
      {
        "name": "stemDispatch",
        "comment": " Dispatch the tasks of a Stem. This function is in the depreciated family of `stemDispatch*`\nfunctions. Use `stemDispatchment*` and `stemIntegrate` instead. ",
        "type": "Gigan.Stem.Stem a b c bad -> ( Gigan.Stem.Stem a b c bad, Gigan.Core.TaskDispatchment bad a )"
      },
      {
        "name": "stemDispatchAs",
        "comment": " Dispatch the tasks of a Stem using some transducer to translate the action list. This function\nis in the depreciated family of `stemDispatch*` functions. Use `stemDispatchment*` and\n`stemIntegrate` instead. ",
        "type": "(List a -> List a') -> Gigan.Stem.Stem a b c bad -> ( Gigan.Stem.Stem a b c bad, Gigan.Core.TaskDispatchment bad a' )"
      },
      {
        "name": "stemDispatchment",
        "comment": " Get the currently waiting dispatchment. ",
        "type": "Gigan.Stem.Stem a b c bad -> Gigan.Core.TaskDispatchment bad a"
      },
      {
        "name": "stemDispatchmentAs",
        "comment": " Get the currently waiting task dispatchment, but apply some action type transformation. ",
        "type": "(List a -> List a') -> Gigan.Stem.Stem a b c bad -> Gigan.Core.TaskDispatchment bad a'"
      },
      {
        "name": "stemIntegrate",
        "comment": " Remove the currently waiting task dispatchment. This should be done only after retrieving any\npossibly waiting dispatchment. ",
        "type": "Gigan.Stem.Stem a b c bad -> Gigan.Stem.Stem a b c bad"
      },
      {
        "name": "stemModel",
        "comment": " Get the model of a stem. ",
        "type": "Gigan.Stem.Stem a b c bad -> b"
      },
      {
        "name": "stemPresent",
        "comment": " Run the present function from the configured OrbiterInput of the Stem on the Stem's current model to produce a ViewOutput, which includes the an element of the Stem's view type, and a TaskDispatchment for any desired asynchronous tasks.\nThis takes an address for actions to be sent to, the current time, and the Stem. ",
        "type": "Signal.Address (List a) -> Time.Time -> Gigan.Stem.Stem a b c bad -> Gigan.Core.ViewOutput a c bad"
      },
      {
        "name": "stemPresentAs",
        "comment": " Same as stemPresent, but with a transformation to apply to action lists before they are sent to the address. ",
        "type": "(List a -> List a') -> Signal.Address (List a') -> Time.Time -> Gigan.Stem.Stem a b c bad -> Gigan.Core.ViewOutput a' c bad"
      },
      {
        "name": "stemReplaceModel",
        "comment": " Create a stem with a different model from a replacement model and an original stem. ",
        "type": "b -> Gigan.Stem.Stem a b c bad -> Gigan.Stem.Stem a b c bad"
      },
      {
        "name": "stemStage",
        "comment": " Run the update function from the configured OrbiterInput of the Stem on the Stem's current model to produce a new model and dispatch any asynchronous tasks desired.\nThis takes an address for actions to be sent to, the current time, and the Stem. ",
        "type": "Signal.Address (List a) -> Time.Time -> Gigan.Stem.Stem a b c bad -> Gigan.Stem.Stem a b c bad"
      },
      {
        "name": "stemStageAs",
        "comment": " Same as stemStage, but with a transformation to apply to action lists before they are sent to the address. ",
        "type": "(List a -> List a') -> Signal.Address (List a') -> Time.Time -> Gigan.Stem.Stem a b c bad -> Gigan.Stem.Stem a b c bad"
      },
      {
        "name": "stemUpdate",
        "comment": " Run the update function from the configured OrbiterInput of the Stem on the Stem's current model to produce a new model and dispatch any asynchronous tasks desired.\nThis takes a list of actions, the current time, and the Stem. ",
        "type": "List a -> Time.Time -> Gigan.Stem.Stem a b c bad -> Gigan.Stem.Stem a b c bad"
      }
    ],
    "generated-with-elm-version": "0.16.0"
  },
  {
    "name": "Gigan.Error",
    "comment": " This module has is the internal error type for Gigan.\n\n# Definitions\n@docs Error, ErrorType(OtherError, DecoderError, RemoteError, UserError)\n\n# Constructor\n@docs reportError\n\n",
    "aliases": [
      {
        "name": "Error",
        "comment": " Error record. ",
        "args": [],
        "type": "{ error : Gigan.Error.ErrorType, desc : String }"
      }
    ],
    "types": [
      {
        "name": "ErrorType",
        "comment": " Type of error that occurred in Gigan. ",
        "args": [],
        "cases": [
          [
            "OtherError",
            []
          ],
          [
            "DecoderError",
            []
          ],
          [
            "RemoteError",
            [
              "Json.Encode.Value"
            ]
          ],
          [
            "UserError",
            [
              "Json.Encode.Value"
            ]
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "reportError",
        "comment": " Report an error. Given an ErrorType and a String describing what went wrong humanly, create\nan error record.  ",
        "type": "Gigan.Error.ErrorType -> String -> Gigan.Error.Error"
      }
    ],
    "generated-with-elm-version": "0.16.0"
  },
  {
    "name": "Gigan.Layout",
    "comment": " A very nice ruler snapping system for layouts. Actual documentation underway.\n\n# Definitions\n@docs Axis, Bounds, Group, Item, Rule\n\n# Ruler Guide Manipulation\n@docs adjustedRule, horizontalRule, horizontalRuleBetween, horizontalRuleCentered, itemHorizontalRule, itemRule, itemVerticalRule, ruleBetween, ruleCenter, snapToRule, towardsRule, towardsRuleRelative, verticalRule, verticalRuleBetween, verticalRuleCentered\n\n# Grouping and Group Operations\n@docs appendGroup, group, groupAt, groupAtBefore, groupElements, groupFromArray, groupFromDict, groupSize, prependGroup, computed, butBefore, butBeforeAt, butBeforeSlice, thenDo, thenDoAt, thenDoSlice, flatten, flattenOutTo, flattenTo, flattenWithin, flattenWithinOutTo\n\n# Group Spacing and Distribution.\n@docs spacedBetween, spacedBy, regularly, vertically, horizontally\n\n# Bounds Definitions\n@docs defBounds, autoBounds, boundsHeight, boundsLower, boundsSize, boundsUpper, boundsWidth, clampedBounds, clampedInnerBounds, clampedOuterBounds\n\n# Item Grabs\n@docs grabItem, grabItemRelative, grabItemRelativeX, grabItemRelativeY, grabItemX, grabItemY\n\n# Item Metrics\n@docs itemBounds, itemWidth, itemHeight, itemSize\n\n# Item Placement\n@docs lerpOf, move, moveX, moveY, place, placeX, placeY\n\n# Create and Display Items\n@docs emptyItem, toItem, fromItem\n\n",
    "aliases": [
      {
        "name": "Item",
        "comment": " An item, which represents an Elm Element with a position and a handle. ",
        "args": [],
        "type": "{ elem : Graphics.Element.Element , x : Int , u : Int , y : Int , v : Int }"
      }
    ],
    "types": [
      {
        "name": "Axis",
        "comment": " An axis along which to evenly distribute by spacing or handle position. ",
        "args": [],
        "cases": []
      },
      {
        "name": "Bounds",
        "comment": " A bounding box, given as a minimum and a maximum. ",
        "args": [],
        "cases": []
      },
      {
        "name": "Group",
        "comment": " Group is an opaque type that represents a grouped set of items with a pending set of transformations. ",
        "args": [],
        "cases": []
      },
      {
        "name": "Rule",
        "comment": " A guide ruler defined as either a vertical or a horizontal axis aligned line. ",
        "args": [],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "adjustedRule",
        "comment": " Adjust a horizontal or vertical ruler. ",
        "type": "(Int -> Gigan.Layout.Rule) -> Int -> Gigan.Layout.Rule -> Gigan.Layout.Rule"
      },
      {
        "name": "appendGroup",
        "comment": " Append two groups, resulting a group containing the elements from `grp` first and the\nelements of `grp'` second. ",
        "type": "Gigan.Layout.Group -> Gigan.Layout.Group -> Gigan.Layout.Group"
      },
      {
        "name": "autoBounds",
        "comment": " Automatic bounds. ",
        "type": "Gigan.Layout.Bounds"
      },
      {
        "name": "boundsHeight",
        "comment": " Get the width of a bounding box, defined as boundsSize >> snd ",
        "type": "Gigan.Layout.Bounds -> Int"
      },
      {
        "name": "boundsLower",
        "comment": " Get the minimum bound if a minimum bound is defined. ",
        "type": "Gigan.Layout.Bounds -> Maybe.Maybe ( Int, Int )"
      },
      {
        "name": "boundsSize",
        "comment": " Get the size of a bounding box if both maximum and minimum bounds are defined, otherwise (0, 0). ",
        "type": "Gigan.Layout.Bounds -> ( Int, Int )"
      },
      {
        "name": "boundsUpper",
        "comment": " Get the maximum bound if a maximum bound is defined. ",
        "type": "Gigan.Layout.Bounds -> Maybe.Maybe ( Int, Int )"
      },
      {
        "name": "boundsWidth",
        "comment": " Get the width of a bounding box, defined as boundsSize >> fst ",
        "type": "Gigan.Layout.Bounds -> Int"
      },
      {
        "name": "butBefore",
        "comment": " Apply some transformation to every item in the group before the pending transformations. ",
        "type": "(Gigan.Layout.Item -> Gigan.Layout.Item) -> Gigan.Layout.Group -> Gigan.Layout.Group"
      },
      {
        "name": "butBeforeAt",
        "comment": " Apply some transformation to the item at a particular index in the group before the pending transformations. ",
        "type": "Int -> (Gigan.Layout.Item -> Gigan.Layout.Item) -> Gigan.Layout.Group -> Gigan.Layout.Group"
      },
      {
        "name": "butBeforeSlice",
        "comment": " Apply some transformation to the items in a particular slice of the group before the pending transformations. ",
        "type": "Int -> Int -> (Gigan.Layout.Item -> Gigan.Layout.Item) -> Gigan.Layout.Group -> Gigan.Layout.Group"
      },
      {
        "name": "clampedBounds",
        "comment": " Clamp a bounding box to some inner bounding box and some outer bounding box. Either the inner\nor the outer bounding box may be autoBounds, so this may also only clamp an inner or an outer limit,\nor neither. ",
        "type": "Gigan.Layout.Bounds -> Gigan.Layout.Bounds -> Gigan.Layout.Bounds -> Gigan.Layout.Bounds"
      },
      {
        "name": "clampedInnerBounds",
        "comment": " clampedInnerBounds myBounds = clampedBounds myBounds autoBounds ",
        "type": "Gigan.Layout.Bounds -> Gigan.Layout.Bounds -> Gigan.Layout.Bounds"
      },
      {
        "name": "clampedOuterBounds",
        "comment": " clampedOuterBounds myBounds = clampedBounds autoBounds myBounds ",
        "type": "Gigan.Layout.Bounds -> Gigan.Layout.Bounds -> Gigan.Layout.Bounds"
      },
      {
        "name": "computed",
        "comment": " Run any pending transformations on all group items. For the most part, this can be avoided, but it should be\ndone if you are planning to get a lot of items back from the group transformed, or else the work of applying the\npending group transforms will be done at least twice, once when you retrieve the item using groupAt and once when\nyou flatten the group to produce an item. ",
        "type": "Gigan.Layout.Group -> Gigan.Layout.Group"
      },
      {
        "name": "defBounds",
        "comment": " Define a definite bounding box. ",
        "type": "Int -> Int -> Int -> Int -> Gigan.Layout.Bounds"
      },
      {
        "name": "emptyItem",
        "comment": " An empty layout item. ",
        "type": "Gigan.Layout.Item"
      },
      {
        "name": "flatten",
        "comment": " Flatten a group using automatic bounds for the inner and outer bounds. This will produce the\ntightest bounding box possible around the target, and place the handle at (0, 0) relative to the resulting\nbounding box. This can result in the handle being placed outside of the group, but this can be desirable for\npositioning. For example, I may want to grab something at (-5, -5), so I can position it's top left\ncorner relative to some outer box with (5, 5) padding. ",
        "type": "Gigan.Layout.Group -> Gigan.Layout.Item"
      },
      {
        "name": "flattenOutTo",
        "comment": " Flatten a group using only an inner bound, which is equivalent to\n\n    flattenWithinOutTo outer autoBounds\n",
        "type": "Gigan.Layout.Bounds -> Gigan.Layout.Group -> Gigan.Layout.Item"
      },
      {
        "name": "flattenTo",
        "comment": " Flatten a group using an exact bound. If this is specified to be autoBounds, then the following\nequivalency holds:\n\n    flattenTo autoBounds group == flatten group\n\nOtherwise, the items in the group are positioned in the resulting item relative to the top left corner of the bounds and\nthe resulting item shall have the exact size of the given bounds. ",
        "type": "Gigan.Layout.Bounds -> Gigan.Layout.Group -> Gigan.Layout.Item"
      },
      {
        "name": "flattenWithin",
        "comment": " Flatten a group using only an outer bound, which is equivalent to\n\n    flattenWithinOutTo autoBounds outer\n",
        "type": "Gigan.Layout.Bounds -> Gigan.Layout.Group -> Gigan.Layout.Item"
      },
      {
        "name": "flattenWithinOutTo",
        "comment": " Flatten a group using an inner and an outer bound to clamp the size of the resulting item.\n",
        "type": "Gigan.Layout.Bounds -> Gigan.Layout.Bounds -> Gigan.Layout.Group -> Gigan.Layout.Item"
      },
      {
        "name": "fromItem",
        "comment": " Get the Graphics Element from an Item. Note that this will get the original Element back,\nunaffected by any positioning done using placement and group operations. To produce Graphics\nElements with finished layouts, refer to the flatten functions. ",
        "type": "Gigan.Layout.Item -> Graphics.Element.Element"
      },
      {
        "name": "grabItem",
        "comment": " Grab an item, producing a handle. This defines a point on the item called the \"handle\" that is\nplaced exactly at item's coordinates. If I say\n\n  grabItem 0 0\n\nthen that would grab the top left corner. u and v and given as window coordinates relative to the\ntop left corner of the item. ",
        "type": "Int -> Int -> Gigan.Layout.Item -> Gigan.Layout.Item"
      },
      {
        "name": "grabItemRelative",
        "comment": " Grab an item in normalized coordinates relative to it's size. This means that (1, 1) is the\nbottom right corner, and (0, 0) is the top left corner. ",
        "type": "Float -> Float -> Gigan.Layout.Item -> Gigan.Layout.Item"
      },
      {
        "name": "grabItemRelativeX",
        "comment": " Grab an item by it's x coordinate relative to the item's size. ",
        "type": "Float -> Gigan.Layout.Item -> Gigan.Layout.Item"
      },
      {
        "name": "grabItemRelativeY",
        "comment": " Grab an item by it's y coordinate relative to the item's size. ",
        "type": "Float -> Gigan.Layout.Item -> Gigan.Layout.Item"
      },
      {
        "name": "grabItemX",
        "comment": " Grab an item by it's x coordinate. ",
        "type": "Int -> Gigan.Layout.Item -> Gigan.Layout.Item"
      },
      {
        "name": "grabItemY",
        "comment": " Grab an item by it's y coordinate. ",
        "type": "Int -> Gigan.Layout.Item -> Gigan.Layout.Item"
      },
      {
        "name": "group",
        "comment": " Create an item group from a list. ",
        "type": "List Gigan.Layout.Item -> Gigan.Layout.Group"
      },
      {
        "name": "groupAt",
        "comment": " Retrieve the item at a given index in the group, or Nothing if the index is out of bounds. If\nthere are waiting transformations, a copy of the item with those transformations applied will be\ngiven. ",
        "type": "Int -> Gigan.Layout.Group -> Maybe.Maybe Gigan.Layout.Item"
      },
      {
        "name": "groupAtBefore",
        "comment": " Retrieve the item at a given index in the group, or Nothing if the index is out of bounds. The\nitem will be retrieved in it's original state without any pending group transformations applied. ",
        "type": "Int -> Gigan.Layout.Group -> Maybe.Maybe Gigan.Layout.Item"
      },
      {
        "name": "groupElements",
        "comment": " This is a shortcut for grouping graphics elements, which is very useful for compositing graphics\nelements such as images directly for layering effects. ",
        "type": "List Graphics.Element.Element -> Gigan.Layout.Group"
      },
      {
        "name": "groupFromArray",
        "comment": " Create an item group from an array. ",
        "type": "Array.Array Gigan.Layout.Item -> Gigan.Layout.Group"
      },
      {
        "name": "groupFromDict",
        "comment": " Create an item group from a dictionary. ",
        "type": "Dict.Dict comparable Gigan.Layout.Item -> Gigan.Layout.Group"
      },
      {
        "name": "groupSize",
        "comment": " Get the size of the group. ",
        "type": "Gigan.Layout.Group -> Int"
      },
      {
        "name": "horizontalRule",
        "comment": " Create a new horizontal ruler at the given y coordinate. ",
        "type": "Int -> Gigan.Layout.Rule"
      },
      {
        "name": "horizontalRuleBetween",
        "comment": " Shorthand for ruleBetween horizontalRule ",
        "type": "Int -> Int -> Float -> Gigan.Layout.Rule"
      },
      {
        "name": "horizontalRuleCentered",
        "comment": " Shorthand for ruleCenter horizontalRule ",
        "type": "Int -> Int -> Gigan.Layout.Rule"
      },
      {
        "name": "horizontally",
        "comment": " Do a distribution horizontally. ",
        "type": "Gigan.Layout.Axis"
      },
      {
        "name": "itemBounds",
        "comment": " Get the resultant bounding box of an item, given it's placement and handle. ",
        "type": "Gigan.Layout.Item -> Gigan.Layout.Bounds"
      },
      {
        "name": "itemHeight",
        "comment": " Get the height of an item. ",
        "type": "Gigan.Layout.Item -> Int"
      },
      {
        "name": "itemHorizontalRule",
        "comment": " Create a horizontal ruler aligned with an item. ",
        "type": "Gigan.Layout.Item -> Gigan.Layout.Rule"
      },
      {
        "name": "itemRule",
        "comment": " Create a vertical or a horizontal ruler aligned with an item. ",
        "type": "(Int -> Gigan.Layout.Rule) -> Gigan.Layout.Item -> Gigan.Layout.Rule"
      },
      {
        "name": "itemSize",
        "comment": " Get the size of an Item. ",
        "type": "Gigan.Layout.Item -> ( Int, Int )"
      },
      {
        "name": "itemVerticalRule",
        "comment": " Create a vertical ruler aligned with an item. ",
        "type": "Gigan.Layout.Item -> Gigan.Layout.Rule"
      },
      {
        "name": "itemWidth",
        "comment": " Get the width of an item. ",
        "type": "Gigan.Layout.Item -> Int"
      },
      {
        "name": "lerpOf",
        "comment": " Modify any of the item manipulation primitives by linearly interpolating the handle and coordinates\nbetween the current and output values. This provides the basic building block for transitional animations.\nEasing functions could quite easily be implemented on top of this. ",
        "type": "(Gigan.Layout.Item -> Gigan.Layout.Item) -> Float -> Gigan.Layout.Item -> Gigan.Layout.Item"
      },
      {
        "name": "move",
        "comment": " Move an item. ",
        "type": "Int -> Int -> Gigan.Layout.Item -> Gigan.Layout.Item"
      },
      {
        "name": "moveX",
        "comment": " Move an item horizontally. ",
        "type": "Int -> Gigan.Layout.Item -> Gigan.Layout.Item"
      },
      {
        "name": "moveY",
        "comment": " Move an item vertically. ",
        "type": "Int -> Gigan.Layout.Item -> Gigan.Layout.Item"
      },
      {
        "name": "place",
        "comment": " Place the handle of an item at these coordinates. ",
        "type": "Int -> Int -> Gigan.Layout.Item -> Gigan.Layout.Item"
      },
      {
        "name": "placeX",
        "comment": " Place the handle of an item at this x coordinate. ",
        "type": "Int -> Gigan.Layout.Item -> Gigan.Layout.Item"
      },
      {
        "name": "placeY",
        "comment": " Place the handle of an item at this y coordinate. ",
        "type": "Int -> Gigan.Layout.Item -> Gigan.Layout.Item"
      },
      {
        "name": "prependGroup",
        "comment": " Prepend a group before another, resulting a group containing the elements from `grp` second and\nthe elements of `grp'` first. ",
        "type": "Gigan.Layout.Group -> Gigan.Layout.Group -> Gigan.Layout.Group"
      },
      {
        "name": "regularly",
        "comment": " Distribute the items in the group along some Axis given a starting coordinate and an ending\ncoordinate, such that the handles of the items are evenly distributed between the starting and the\nending coordinates. The height or width of this vertical or horizontal distribution is dependent on\nthe positioning of the handles on the items, and the coordinate not effected by the distribution is\nleft in place. ",
        "type": "Gigan.Layout.Axis -> Int -> Int -> Gigan.Layout.Group -> Gigan.Layout.Group"
      },
      {
        "name": "ruleBetween",
        "comment": " Given a ruler direction (verticalRule or horizontalRule), a lower and an upper bound, and some\nfloat t between 0 and 1, linearly interpolate between the lower and upper bound by t. ",
        "type": "(Int -> Gigan.Layout.Rule) -> Int -> Int -> Float -> Gigan.Layout.Rule"
      },
      {
        "name": "ruleCenter",
        "comment": " Given a ruler direction (verticalRule or horizontalRule), a lower bound, and an upper bound,\ncenter a ruler between the lower and the upper bound. The following equivalencies hold:\n\n    ruleCenter verticalRule x0 x1 == ruleBetween verticalRule x0 x1 0.5\n    ruleCenter horizontalRule y0 y1 == ruleBetween horizontalRule y0 y1 0.5\n\n",
        "type": "(Int -> Gigan.Layout.Rule) -> Int -> Int -> Gigan.Layout.Rule"
      },
      {
        "name": "snapToRule",
        "comment": " Snap an item's handle to a vertical or horizontal ruler. ",
        "type": "Gigan.Layout.Rule -> Gigan.Layout.Item -> Gigan.Layout.Item"
      },
      {
        "name": "spacedBetween",
        "comment": " Distribute the items in the group along some Axis given a starting coordinate and an ending\ncoordinate, such that the spaces between all of the items are even, resulting in a justified layout.\nVertical distribution is done top to bottom, horizontal distribution is done left to right.\n\nThe height or width of this vertical or horizontal distribution is\n\n    to - from\n\nand the coordinate not effected by the distribution is left in place.\n",
        "type": "Gigan.Layout.Axis -> Int -> Int -> Gigan.Layout.Group -> Gigan.Layout.Group"
      },
      {
        "name": "spacedBy",
        "comment": " Distribute the items in the group along some Axis given a starting coordinate and spacing given\nin window coordinates, resulting in an evenly spaced horizontal or vertical distribution. Vertical\ndistribution is done top to bottom, horizontal distribution is done left to right.\n\nThe height or width of this vertical or horizontal distribution is\n\n    from + siz * (n - 1) + (sum itemHeight items)\n\nand the coordinate not effected by the distribution is left in place.\n\n",
        "type": "Gigan.Layout.Axis -> Int -> Int -> Gigan.Layout.Group -> Gigan.Layout.Group"
      },
      {
        "name": "thenDo",
        "comment": " Apply some transformation to every item in the group after the pending transformations. ",
        "type": "(Gigan.Layout.Item -> Gigan.Layout.Item) -> Gigan.Layout.Group -> Gigan.Layout.Group"
      },
      {
        "name": "thenDoAt",
        "comment": " Apply some transformation to the item at a particular index in the group after the pending transformations. ",
        "type": "Int -> (Gigan.Layout.Item -> Gigan.Layout.Item) -> Gigan.Layout.Group -> Gigan.Layout.Group"
      },
      {
        "name": "thenDoSlice",
        "comment": " Apply some transformation to the items in a particular slice of the group after the pending transformations. ",
        "type": "Int -> Int -> (Gigan.Layout.Item -> Gigan.Layout.Item) -> Gigan.Layout.Group -> Gigan.Layout.Group"
      },
      {
        "name": "toItem",
        "comment": " Convert a Graphics Element to an Item ",
        "type": "Graphics.Element.Element -> Gigan.Layout.Item"
      },
      {
        "name": "towardsRule",
        "comment": " Move an item's handle toward a vertical or horizontal ruler by some constant amount. ",
        "type": "Gigan.Layout.Rule -> Int -> Gigan.Layout.Item -> Gigan.Layout.Item"
      },
      {
        "name": "towardsRuleRelative",
        "comment": " Move an item's handle toward a vertical or horizontal ruler by some factor t  ",
        "type": "Gigan.Layout.Rule -> Float -> Gigan.Layout.Item -> Gigan.Layout.Item"
      },
      {
        "name": "verticalRule",
        "comment": " Create a new vertical ruler at the given x coordinate. ",
        "type": "Int -> Gigan.Layout.Rule"
      },
      {
        "name": "verticalRuleBetween",
        "comment": " Shorthand for ruleBetween verticalRule ",
        "type": "Int -> Int -> Float -> Gigan.Layout.Rule"
      },
      {
        "name": "verticalRuleCentered",
        "comment": " Shorthand for ruleCenter verticalRule ",
        "type": "Int -> Int -> Gigan.Layout.Rule"
      },
      {
        "name": "vertically",
        "comment": " Do a distribution vertically. ",
        "type": "Gigan.Layout.Axis"
      }
    ],
    "generated-with-elm-version": "0.16.0"
  },
  {
    "name": "Gigan.Core",
    "comment": " This module is the main application scaffolding. Detailed documentation in progress.\n\n# Definitions\n@docs AgentStatus, ComputedResult, ComputedSuccess, FeedbackMethod, OrbiterInput, OrbiterOutput, OrbiterSnapshot, OrbiterTap, OrbiterTask, TaskDispatchment, UpdatedModel, ViewOutput\n\n# Define Orbiter Programs\n@docs defProgram, defProgram'\n\n# Run Orbiter Programs\n@docs orbits, orbitsWithWork, withInputs, withLazySequenceInputs, withSequenceInputs, sieve, (+-->)\n\n# UpdatedModel and ViewOutput Manipulation\n@docs updated, presented, withTasks, withDispatchment, withChildren, viewOutputTask\n\n# Dispatch Actions and Errors\n@docs actionTask, errorTask, computeTask, computedSuccess, noActions, nilTask\n\n# Intercept and Route Action and Error Outputs\n@docs successTap, errorTap, atomicSuccessTap, asyncSuccessTap, it'sErrorTap, itself, itselfDeferred, thisAddress, thisAddressDeferred, thisCustomAddress, thisCustomAddressDeferred, thisErrorTap, thisForwardTap, thisTap\n\n# Handling Tasks and TaskDispatchment\n@docs combineDispatchments, collapseTasks, dispatchTasks, dispatchmentHasWork, dispatchmentTask, promoteDispatchment\n\n# Manipulate Orbiter Snapshots\n@docs orbiterSnapshot, orbiterSnapshotAddDispatchment, orbiterSnapshotDispatch, orbiterSnapshotPresent, orbiterSnapshotStage, orbiterSnapshotUpdate, performCycle\n\n# Orbiter Task Agents\n@docs orbiterAgent, orbiterSuccessAgent, orbiterFailureAgent, orbiterBinaryAgent, orbiterBlindAgent, orbiterNilAgent, orbiterResultAgent, ignoreError\n\n",
    "aliases": [
      {
        "name": "ComputedResult",
        "comment": " todo doc ",
        "args": [
          "bad",
          "a"
        ],
        "type": "Result.Result bad (Gigan.Core.ComputedSuccess a)"
      },
      {
        "name": "ComputedSuccess",
        "comment": " todo doc ",
        "args": [
          "a"
        ],
        "type": "{ sequence : List a, method : Gigan.Core.FeedbackMethod }"
      },
      {
        "name": "OrbiterInput",
        "comment": " todo doc ",
        "args": [
          "a",
          "b",
          "c",
          "bad"
        ],
        "type": "{ inputs : Lazy.List.LazyList (Signal.Signal (Lazy.List.LazyList a)) , model0 : b , present : Signal.Address (List a) -> Time.Time -> b -> Gigan.Core.ViewOutput a c bad , stage : Signal.Address (List a) -> Time.Time -> b -> Gigan.Core.UpdatedModel a b bad , update : a -> Time.Time -> b -> Gigan.Core.UpdatedModel a b bad }"
      },
      {
        "name": "OrbiterOutput",
        "comment": " todo doc ",
        "args": [
          "a",
          "b",
          "c",
          "bad"
        ],
        "type": "{ view' : Signal.Signal c , model' : Signal.Signal b , now : Signal.Signal Time.Time , actions : Signal.Signal (List a) , tasks : Signal.Signal (Gigan.Core.OrbiterTask bad a) , address : Signal.Address (List a) , lazyAddress : Signal.Address (Lazy.List.LazyList a) }"
      },
      {
        "name": "OrbiterSnapshot",
        "comment": " todo doc ",
        "args": [
          "a",
          "b",
          "bad"
        ],
        "type": "{ model' : b, dispatchment : Gigan.Core.TaskDispatchment bad a }"
      },
      {
        "name": "OrbiterTap",
        "comment": " todo doc ",
        "args": [
          "bad",
          "a"
        ],
        "type": "Signal.Address (List a) -> Gigan.Core.OrbiterTask bad a -> Gigan.Core.OrbiterTask bad a"
      },
      {
        "name": "OrbiterTask",
        "comment": " todo doc ",
        "args": [
          "bad",
          "a"
        ],
        "type": "Task.Task bad (Gigan.Core.ComputedSuccess a)"
      },
      {
        "name": "TaskDispatchment",
        "comment": " todo doc ",
        "args": [
          "bad",
          "a"
        ],
        "type": "{ taskExec : Lazy.List.LazyList (Gigan.Core.OrbiterTask bad a) }"
      },
      {
        "name": "UpdatedModel",
        "comment": " todo doc ",
        "args": [
          "a",
          "b",
          "bad"
        ],
        "type": "{ dispatchment : Gigan.Core.TaskDispatchment bad a, model' : b }"
      },
      {
        "name": "ViewOutput",
        "comment": " todo doc ",
        "args": [
          "a",
          "c",
          "bad"
        ],
        "type": "{ dispatchment : Gigan.Core.TaskDispatchment bad a, view' : c }"
      }
    ],
    "types": [
      {
        "name": "AgentStatus",
        "comment": " todo doc ",
        "args": [
          "bad",
          "a"
        ],
        "cases": []
      },
      {
        "name": "FeedbackMethod",
        "comment": " todo doc ",
        "args": [],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "+-->",
        "comment": " todo doc ",
        "type": "Gigan.Core.OrbiterOutput a b c bad -> (Gigan.Core.OrbiterOutput a b c bad -> Gigan.Core.OrbiterOutput a b c bad) -> Gigan.Core.OrbiterOutput a b c bad"
      },
      {
        "name": "actionTask",
        "comment": " todo doc ",
        "type": "List a -> Gigan.Core.OrbiterTask bad a"
      },
      {
        "name": "asyncSuccessTap",
        "comment": " todo doc ",
        "type": "Signal.Address (List a) -> Gigan.Core.OrbiterTask bad a -> Gigan.Core.OrbiterTask bad a"
      },
      {
        "name": "atomicSuccessTap",
        "comment": " todo doc ",
        "type": "Signal.Address (List a) -> Gigan.Core.OrbiterTask bad a -> Gigan.Core.OrbiterTask bad a"
      },
      {
        "name": "collapseTasks",
        "comment": " todo doc ",
        "type": "Gigan.Core.OrbiterTask bad a -> Gigan.Core.OrbiterTask bad a -> Gigan.Core.OrbiterTask bad a"
      },
      {
        "name": "combineDispatchments",
        "comment": " todo doc ",
        "type": "Gigan.Core.TaskDispatchment bad a -> Gigan.Core.TaskDispatchment bad a -> Gigan.Core.TaskDispatchment bad a"
      },
      {
        "name": "computeTask",
        "comment": " todo doc ",
        "type": "(data -> Gigan.Core.ComputedResult bad a) -> data -> Gigan.Core.OrbiterTask bad a"
      },
      {
        "name": "computedSuccess",
        "comment": " todo doc ",
        "type": "List a -> Gigan.Core.ComputedSuccess a"
      },
      {
        "name": "defProgram",
        "comment": " todo doc ",
        "type": "(Signal.Address (List a) -> Time.Time -> b -> Gigan.Core.ViewOutput a c bad) -> (a -> Time.Time -> b -> Gigan.Core.UpdatedModel a b bad) -> b -> Gigan.Core.OrbiterInput a b c bad"
      },
      {
        "name": "defProgram'",
        "comment": " todo doc ",
        "type": "(Signal.Address (List a) -> Time.Time -> b -> Gigan.Core.ViewOutput a c bad) -> (Signal.Address (List a) -> Time.Time -> b -> Gigan.Core.UpdatedModel a b bad) -> (a -> Time.Time -> b -> Gigan.Core.UpdatedModel a b bad) -> b -> Gigan.Core.OrbiterInput a b c bad"
      },
      {
        "name": "dispatchTasks",
        "comment": " todo doc ",
        "type": "List (Gigan.Core.OrbiterTask bad a) -> Gigan.Core.TaskDispatchment bad a"
      },
      {
        "name": "dispatchmentHasWork",
        "comment": " todo doc ",
        "type": "Gigan.Core.TaskDispatchment bad a -> Bool"
      },
      {
        "name": "dispatchmentTask",
        "comment": " todo doc ",
        "type": "Gigan.Core.TaskDispatchment bad a -> Gigan.Core.OrbiterTask bad a"
      },
      {
        "name": "errorTap",
        "comment": " todo doc ",
        "type": "Signal.Address (List a) -> (bad -> List a) -> Gigan.Core.OrbiterTask bad a -> Gigan.Core.OrbiterTask bad a"
      },
      {
        "name": "errorTask",
        "comment": " todo doc ",
        "type": "bad -> Gigan.Core.OrbiterTask bad a"
      },
      {
        "name": "ignoreError",
        "comment": " todo doc ",
        "type": "bad -> List a"
      },
      {
        "name": "it'sErrorTap",
        "comment": " todo doc ",
        "type": "(bad -> List a) -> Gigan.Core.OrbiterOutput a b c bad -> Gigan.Core.OrbiterOutput a b c bad"
      },
      {
        "name": "itself",
        "comment": " todo doc ",
        "type": "Gigan.Core.OrbiterOutput a b c bad -> Gigan.Core.OrbiterOutput a b c bad"
      },
      {
        "name": "itselfDeferred",
        "comment": " todo doc ",
        "type": "Gigan.Core.OrbiterOutput a b c bad -> Gigan.Core.OrbiterOutput a b c bad"
      },
      {
        "name": "nilTask",
        "comment": " todo doc ",
        "type": "Gigan.Core.OrbiterTask bad a"
      },
      {
        "name": "noActions",
        "comment": " todo doc ",
        "type": "List a"
      },
      {
        "name": "orbiterAgent",
        "comment": " todo doc ",
        "type": "(x -> Gigan.Core.AgentStatus bad a) -> (y -> Gigan.Core.AgentStatus bad a) -> Task.Task y x -> Gigan.Core.OrbiterTask bad a"
      },
      {
        "name": "orbiterBinaryAgent",
        "comment": " todo doc ",
        "type": "Gigan.Core.AgentStatus bad a -> Gigan.Core.AgentStatus bad a -> Task.Task y x -> Gigan.Core.OrbiterTask bad a"
      },
      {
        "name": "orbiterBlindAgent",
        "comment": " todo doc ",
        "type": "Gigan.Core.AgentStatus bad a -> Task.Task y x -> Gigan.Core.OrbiterTask bad a"
      },
      {
        "name": "orbiterFailureAgent",
        "comment": " todo doc ",
        "type": "Gigan.Core.AgentStatus bad a -> (y -> Gigan.Core.AgentStatus bad a) -> Task.Task y x -> Gigan.Core.OrbiterTask bad a"
      },
      {
        "name": "orbiterNilAgent",
        "comment": " todo doc ",
        "type": "Task.Task y x -> Gigan.Core.OrbiterTask bad a"
      },
      {
        "name": "orbiterResultAgent",
        "comment": " todo doc ",
        "type": "(Result.Result y x -> Gigan.Core.AgentStatus bad a) -> Task.Task y x -> Gigan.Core.OrbiterTask bad a"
      },
      {
        "name": "orbiterSnapshot",
        "comment": " todo doc ",
        "type": "b -> Gigan.Core.TaskDispatchment bad a -> Gigan.Core.OrbiterSnapshot a b bad"
      },
      {
        "name": "orbiterSnapshotAddDispatchment",
        "comment": " todo doc ",
        "type": "Gigan.Core.TaskDispatchment bad a -> Gigan.Core.OrbiterSnapshot a b bad -> Gigan.Core.OrbiterSnapshot a b bad"
      },
      {
        "name": "orbiterSnapshotDispatch",
        "comment": " todo doc ",
        "type": "Gigan.Core.OrbiterSnapshot a b bad -> ( Gigan.Core.OrbiterSnapshot a b bad , Gigan.Core.TaskDispatchment bad a )"
      },
      {
        "name": "orbiterSnapshotPresent",
        "comment": " todo doc ",
        "type": "{ k | present : Signal.Address (List a) -> Time.Time -> b -> Gigan.Core.ViewOutput a c bad } -> Signal.Address (List a) -> Time.Time -> Gigan.Core.OrbiterSnapshot a b bad -> Gigan.Core.ViewOutput a c bad"
      },
      {
        "name": "orbiterSnapshotStage",
        "comment": " todo doc ",
        "type": "{ k | stage : Signal.Address (List a) -> Time.Time -> b -> Gigan.Core.UpdatedModel a b bad } -> Signal.Address (List a) -> Time.Time -> Gigan.Core.OrbiterSnapshot a b bad -> Gigan.Core.OrbiterSnapshot a b bad"
      },
      {
        "name": "orbiterSnapshotUpdate",
        "comment": " todo doc ",
        "type": "{ k | update : a -> Time.Time -> b -> Gigan.Core.UpdatedModel a b bad } -> List a -> Time.Time -> Gigan.Core.OrbiterSnapshot a b bad -> Gigan.Core.OrbiterSnapshot a b bad"
      },
      {
        "name": "orbiterSuccessAgent",
        "comment": " todo doc ",
        "type": "(x -> Gigan.Core.AgentStatus bad a) -> Gigan.Core.AgentStatus bad a -> Task.Task y x -> Gigan.Core.OrbiterTask bad a"
      },
      {
        "name": "orbits",
        "comment": " todo doc ",
        "type": "Gigan.Core.OrbiterInput a b c bad -> Gigan.Core.OrbiterOutput a b c bad"
      },
      {
        "name": "orbitsWithWork",
        "comment": " todo doc ",
        "type": "Gigan.Core.OrbiterInput a b c bad -> Gigan.Core.OrbiterTask bad a -> Gigan.Core.OrbiterOutput a b c bad"
      },
      {
        "name": "performCycle",
        "comment": " todo doc ",
        "type": "Gigan.Core.OrbiterInput a b c bad -> Signal.Address (List a) -> ( Time.Time, List a ) -> ( Gigan.Core.OrbiterSnapshot a b bad , Gigan.Core.TaskDispatchment bad a ) -> ( Gigan.Core.OrbiterSnapshot a b bad , Gigan.Core.TaskDispatchment bad a )"
      },
      {
        "name": "presented",
        "comment": " todo doc ",
        "type": "c -> Gigan.Core.ViewOutput a c bad"
      },
      {
        "name": "promoteDispatchment",
        "comment": " todo doc ",
        "type": "(List a -> List a') -> Gigan.Core.TaskDispatchment bad a -> Gigan.Core.TaskDispatchment bad a'"
      },
      {
        "name": "sieve",
        "comment": " todo doc ",
        "type": "Gigan.Core.OrbiterOutput a b c bad -> Signal.Signal (Task.Task z ())"
      },
      {
        "name": "successTap",
        "comment": " todo doc ",
        "type": "Signal.Address (List a) -> Gigan.Core.OrbiterTask bad a -> Gigan.Core.OrbiterTask bad a"
      },
      {
        "name": "thisAddress",
        "comment": " todo doc ",
        "type": "Signal.Address (List a) -> Gigan.Core.OrbiterOutput a b c bad -> Gigan.Core.OrbiterOutput a b c bad"
      },
      {
        "name": "thisAddressDeferred",
        "comment": " todo doc ",
        "type": "Signal.Address (List a) -> Gigan.Core.OrbiterOutput a b c bad -> Gigan.Core.OrbiterOutput a b c bad"
      },
      {
        "name": "thisCustomAddress",
        "comment": " todo doc ",
        "type": "Signal.Address target -> (List a -> target) -> Gigan.Core.OrbiterOutput a b c bad -> Gigan.Core.OrbiterOutput a b c bad"
      },
      {
        "name": "thisCustomAddressDeferred",
        "comment": " todo doc ",
        "type": "Signal.Address target -> (List a -> target) -> Gigan.Core.OrbiterOutput a b c bad -> Gigan.Core.OrbiterOutput a b c bad"
      },
      {
        "name": "thisErrorTap",
        "comment": " todo doc ",
        "type": "Signal.Address (List a) -> (bad -> List a) -> Gigan.Core.OrbiterOutput a b c bad -> Gigan.Core.OrbiterOutput a b c bad"
      },
      {
        "name": "thisForwardTap",
        "comment": " todo doc ",
        "type": "Gigan.Core.OrbiterTap bad a -> Signal.Address target -> (List a -> target) -> Gigan.Core.OrbiterOutput a b c bad -> Gigan.Core.OrbiterOutput a b c bad"
      },
      {
        "name": "thisTap",
        "comment": " todo doc ",
        "type": "Gigan.Core.OrbiterTap bad a -> Signal.Address (List a) -> Gigan.Core.OrbiterOutput a b c bad -> Gigan.Core.OrbiterOutput a b c bad"
      },
      {
        "name": "updated",
        "comment": " todo doc ",
        "type": "b -> Gigan.Core.UpdatedModel a b bad"
      },
      {
        "name": "viewOutputTask",
        "comment": " todo doc ",
        "type": "Gigan.Core.ViewOutput a c bad -> Gigan.Core.OrbiterTask bad a"
      },
      {
        "name": "withChildren",
        "comment": " todo doc ",
        "type": "List { anything | dispatchment : Gigan.Core.TaskDispatchment bad a } -> { anything | dispatchment : Gigan.Core.TaskDispatchment bad a } -> { anything | dispatchment : Gigan.Core.TaskDispatchment bad a }"
      },
      {
        "name": "withDispatchment",
        "comment": " todo doc ",
        "type": "Gigan.Core.TaskDispatchment bad a -> { anything | dispatchment : Gigan.Core.TaskDispatchment bad a } -> { anything | dispatchment : Gigan.Core.TaskDispatchment bad a }"
      },
      {
        "name": "withInputs",
        "comment": " todo doc ",
        "type": "Gigan.Core.OrbiterInput a b c bad -> List (Signal.Signal a) -> Gigan.Core.OrbiterInput a b c bad"
      },
      {
        "name": "withLazySequenceInputs",
        "comment": " todo doc ",
        "type": "Gigan.Core.OrbiterInput a b c bad -> List (Signal.Signal (Lazy.List.LazyList a)) -> Gigan.Core.OrbiterInput a b c bad"
      },
      {
        "name": "withSequenceInputs",
        "comment": " todo doc ",
        "type": "Gigan.Core.OrbiterInput a b c bad -> List (Signal.Signal (List a)) -> Gigan.Core.OrbiterInput a b c bad"
      },
      {
        "name": "withTasks",
        "comment": " todo doc ",
        "type": "List (Gigan.Core.OrbiterTask bad a) -> { anything | dispatchment : Gigan.Core.TaskDispatchment bad a } -> { anything | dispatchment : Gigan.Core.TaskDispatchment bad a }"
      }
    ],
    "generated-with-elm-version": "0.16.0"
  }
]