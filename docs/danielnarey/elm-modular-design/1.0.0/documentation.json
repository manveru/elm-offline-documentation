[{"name":"ModularDesign.FormInput","comment":" ModularDesign's `FormInput` library provides an API for capturing,\naccessing, and validating input from HTML `form` elements. Rather than capturing\nuser input from each individual `input` element on a page, it is often more\nconvenient to wrap multiple `input` elements in a `form` with a `submit` button\nthat triggers input capture. Because Elm's `Html` package does not include a\nbuilt-in set of functions for handling form input, a custom event handler and\ncustom Json decoders are needed to capture input in response to a \"submit\" event\non a form. The `FormInput` library includes constructor functions that make it\neasy to initialize an event handler that will capture form input, decoding it\ninto a dictionary keyed by input `id`. The library also includes reader\nfunctions that enable type-checking on input values, as well as a function that\nconverts a dictionary of input values to JSON.\n\n# Capturing Form Input\n@docs FormInput, formControl, captureOnSubmit, fieldDecoder, formDecoder\n\n# Accessing Form Input\n@docs getInputAt, readStringAt, resolveStringAt\n\n# Converting Form Input to JSON\n@docs formInputToJson, toTypedJson, extractRawJson\n\n# Reading `TypedInput` Values\n@docs readInputAsString, resolveInputAsString, readStringInput\n@docs resolveStringInput, readIntInput, resolveIntInput, readFloatInput\n@docs resolveFloatInput, readBoolInput, resolveBoolInput, readCustomInput\n@docs resolveCustomInput\n\n","aliases":[{"name":"FormInput","comment":" Represents input captured from a form with multiple fields. Implemented as a\ndictionary, where the *key* is the `id` of the input element and the *value* is\nits captured value as `TypedInput`.\n","args":[],"type":"Dict.Dict String ModularDesign.TypedInput"}],"types":[],"values":[{"name":"captureOnSubmit","comment":" Constructor that takes a `Json`\n[`Decoder`](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Decode#Decoder)\nas an argument and returns an\n[`Html.Attribute`](http://package.elm-lang.org/packages/elm-lang/html/latest/Html#Attribute)\nencoding an event handler triggered by \"submit\". The decoder specifies the input\nfield(s) to be captured and the type that will be returned when the input is\ndecoded.\n\n    container \"form\" [ inputField, submitButton ]\n      |> withObserver (captureOnSubmit inputDecoder)\n\nSee CaptureOnSubmit.elm for a full working example.\n","type":"Json.Decode.Decoder msg -> Html.Attribute msg"},{"name":"extractRawJson","comment":" Return a JavaScript value from `TypedInput` without attempting to decode. If\nthe `TypedInput` value has been captured from an input element, the returned\nvalue will always be a JavaScript string. Useful for debugging.\n\n    formInput\n      |> getInputAt \"userAge\"\n      |> Result.withDefault (IntInput Json.Encode.null)\n      |> extractRawJson\n\n    --> \"33\" : Json.Decode.Value\n","type":"ModularDesign.TypedInput -> Json.Decode.Value"},{"name":"fieldDecoder","comment":" Constructor that takes an `HtmlElement` representing a form field and\nreturns a `Json`\n[`Decoder`](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Decode#Decoder).\nWhen triggered by a \"submit\" event on the parent form, this decoder will return\na tuple containing the input element's `id` attribute and its current `value`,\nencoded as `TypedInput`. For the decoder work properly, the input element must\nbe assigned a unique `id` and its `inputType` must be defined.\n\n    inputDecoder =\n      rootElement inputField\n        |> fieldDecoder\n\nSee FieldDecoder.elm for a full working example.\n","type":"ModularDesign.HtmlElement msg -> Json.Decode.Decoder ( String, ModularDesign.TypedInput )"},{"name":"formControl","comment":" Given a list of `HtmlTree` nodes, construct a `form` element with an\nobserver that captures values from each input element contained in the list and\nreturns those values as `FormInput`. The first argument (a constructor that\naccepts `FormInput`) specifies the message that will be passed to the program's\nupdate function when a \"submit\" event is triggered on the form. The `HtmlTree`\nthat is returned will have the `form` element at the root, with the listed nodes\nas its children.\n\nSee FormControl.elm for a full working example.\n","type":"(ModularDesign.FormInput.FormInput -> msg) -> List (ModularDesign.HtmlTree msg) -> ModularDesign.HtmlTree msg"},{"name":"formDecoder","comment":" Constructor that takes a list of `HtmlTree` nodes representing internal\nelements within a `form` and returns a `Json`\n[`Decoder`](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Decode#Decoder).\nWhen triggered by a \"submit\" event on the form, this decoder will return a\n[`Dict`](http://package.elm-lang.org/packages/elm-lang/core/latest/Dict#Decoder)\ncontaining values for each `input` element, keyed by `id`. For the decoder work\nproperly, each input element must be assigned a unique `id` string and its\n`inputType` must be defined.\n\n    inputDict =\n      formDecoder [ input1, input2 ]\n        |> Json.map Submit\n\n    form =\n      container \"form\" [ input1, input2, submitButton ]\n        |> withObserver (captureOnSubmit inputDict)\n\nSee FormDecoder.elm for a full working example.\n","type":"List (ModularDesign.HtmlTree msg) -> Json.Decode.Decoder ModularDesign.FormInput.FormInput"},{"name":"formInputToJson","comment":" Convert `FormInput` to JSON with the\n[`Json.Encode.object`](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Encode#object)\nfunction. Before encoding, the `toTypedJson` function is used to perform type\nchecking and conversion on input values.\n\n    formInput\n      |> formInputToJson\n\n    --> { userAge = 33, userName = \"Bob\" } : Json.Decode.Value\n","type":"ModularDesign.FormInput.FormInput -> Json.Decode.Value"},{"name":"getInputAt","comment":" Given a string representing an `id`, look up the value of the associated\ninput element in `FormInput` and return the result as `TypedInput`, or return\nan error message.\n\n    --simulated input\n    input1 = ( \"userName\", StringInput (Json.Encode.string \"Bob\") )\n    input2 = (\"userAge\", IntInput (Json.Encode.string \"33\") )\n    formInput = Dict.fromList [ input1, input2 ]\n\n    formInput\n      |> getInputAt \"userName\"\n\n    --> Ok (StringInput \"Bob\")\n","type":"String -> ModularDesign.FormInput.FormInput -> Result.Result String ModularDesign.TypedInput"},{"name":"readBoolInput","comment":" Decode a `BoolInput` value as a string, then attempt to convert the string\nto a `Bool`; return an error message if the string decoder fails, if type\nconversion fails, or if the argument is a type other than `BoolInput`. Type\nconversion expects a string value of \"true\" or \"false\", ignoring case.\n\n    formInput\n      |> getInputAt \"over18Years\"\n      |> Result.withDefault (BoolInput Json.Encode.null)\n      |> readBoolInput\n\n    --> Ok True\n","type":"ModularDesign.TypedInput -> Result.Result String Bool"},{"name":"readCustomInput","comment":" Given a `Json`\n[`Decoder`](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Decode#Decoder),\nattempt to decode a `CustomInput` value; return an error message if the decoder\nfails or if the argument is a type other than `CustomInput`.\n","type":"Json.Decode.Decoder a -> ModularDesign.TypedInput -> Result.Result String a"},{"name":"readFloatInput","comment":" Decode a `FloatInput` value as a string, then attempt to convert the string\nto a `Float`; return an error message if the string decoder fails, if type\nconversion fails, or if the argument is a type other than `FloatInput`.\n\n    formInput\n      |> getInputAt \"userWeight\"\n      |> Result.withDefault (FloatInput Json.Encode.null)\n      |> readFloatInput\n\n    --> Ok 160.5\n","type":"ModularDesign.TypedInput -> Result.Result String Float"},{"name":"readInputAsString","comment":" Decode `TypedInput` as a string, or return an error message if the decoder\nfails.\n\n    formInput\n      |> getInputAt \"userAge\"\n      |> Result.withDefault (IntInput Json.Encode.null)\n      |> readInputAsString\n\n    --> Ok \"33\"\n","type":"ModularDesign.TypedInput -> Result.Result String String"},{"name":"readIntInput","comment":" Decode an `IntInput` value as a string, then attempt to convert the string\nto an `Int`; return an error message if the string decoder fails, if type\nconversion fails, or if the argument is a type other than `IntInput`.\n\n    formInput\n      |> getInputAt \"userAge\"\n      |> Result.withDefault (IntInput Json.Encode.null)\n      |> readIntInput\n\n    --> Ok 33\n","type":"ModularDesign.TypedInput -> Result.Result String Int"},{"name":"readStringAt","comment":" Given a string representing an `id`, look up the value of the associated\ninput element and decode the result as a `String`, or return an error message.\n\n    formInput\n      |> readStringAt \"userName\"\n\n    --> Ok \"Bob\"\n","type":"String -> ModularDesign.FormInput.FormInput -> Result.Result String String"},{"name":"readStringInput","comment":" Decode a `StringInput` value as a string; return an error message if the\ndecoder fails or if the argument is a type other than `StringInput`.\n\n    formInput\n      |> getInputAt \"userName\"\n      |> Result.withDefault (StringInput Json.Encode.null)\n      |> readStringInput\n\n    --> Ok \"Bob\"\n","type":"ModularDesign.TypedInput -> Result.Result String String"},{"name":"resolveBoolInput","comment":" Decode a `BoolInput` value as a string, then attempt to convert the string\nto an `Bool`; return a default value if the string decoder fails, if type\nconversion fails, or if the argument is a type other than `BoolInput`. Type\nconversion expects a string value of \"true\" or \"false\", ignoring case.\n\n    formInput\n      |> getInputAt \"over18Years\"\n      |> Result.withDefault (BoolInput Json.Encode.null)\n      |> resolveBoolInput False\n\n    --> True\n","type":"Bool -> ModularDesign.TypedInput -> Bool"},{"name":"resolveCustomInput","comment":" Given a `Json`\n[`Decoder`](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Decode#Decoder),\nattempt to decode a `CustomInput` value; return a default value if the decoder\nfails or if the argument is a type other than `CustomInput`.\n","type":"Json.Decode.Decoder a -> a -> ModularDesign.TypedInput -> a"},{"name":"resolveFloatInput","comment":" Decode a `FloatInput` value as a string, then attempt to convert the string\nto an `Float`; return a default value if the string decoder fails, if type\nconversion fails, or if the argument is a type other than `FloatInput`.\n\n    formInput\n      |> getInputAt \"userWeight\"\n      |> Result.withDefault (FloatInput Json.Encode.null)\n      |> resolveFloatInput -1\n\n    --> 160.5\n","type":"Float -> ModularDesign.TypedInput -> Float"},{"name":"resolveInputAsString","comment":" Decode `TypedInput` as a string, returning a default string if the decoder\nfails.\n\n    formInput\n      |> getInputAt \"userAge\"\n      |> resolveInputAsString \"NoAge\"\n\n    --> \"33\"\n","type":"String -> ModularDesign.TypedInput -> String"},{"name":"resolveIntInput","comment":" Decode an `IntInput` value as a string, then attempt to convert the string\nto an `Int`; return a default value if the string decoder fails, if type\nconversion fails, or if the argument is a type other than `IntInput`.\n\n    formInput\n      |> getInputAt \"userAge\"\n      |> Result.withDefault (IntInput Json.Encode.null)\n      |> resolveIntInput -1\n\n    --> 33\n","type":"Int -> ModularDesign.TypedInput -> Int"},{"name":"resolveStringAt","comment":" Given a string representing an `id`, look up the value of the associated\ninput element and decode the result as a `String`, returning a default string if\nlook-up or decoding fails. The first argument is the default and the second\nargument is the key.\n\n    formInput\n      |> resolveStringAt \"NoName\" \"userName\"\n\n    --> \"Bob\"\n","type":"String -> String -> ModularDesign.FormInput.FormInput -> String"},{"name":"resolveStringInput","comment":" Decode a `StringInput` value as a string; return a default string if the\ndecoder fails or if the argument is a type other than `StringInput`.\n\n    formInput\n      |> getInputAt \"userName\"\n      |> Result.withDefault (StringInput Json.Encode.null)\n      |> resolveStringInput \"NoName\"\n\n    --> \"Bob\"\n","type":"String -> ModularDesign.TypedInput -> String"},{"name":"toTypedJson","comment":" Convert `TypedInput` to a Json `Value` of the corresponding type. Because\ninput from a form element is always captured as a JavaScript string, numeric or\nboolean input must first be decoded to a `String` before it can be encoded as a\nJavaScript number or boolean. This function takes care of both steps and passes\nalong any error messages in type conversion.\n\n    formInput\n      |> getInputAt \"userAge\"\n      |> Result.withDefault (IntInput Json.Encode.null)\n      |> toTypedJson\n\n    --> Ok 33 : Result String Json.Decode.Value\n","type":"ModularDesign.TypedInput -> Result.Result String Json.Decode.Value"}],"generated-with-elm-version":"0.17.0"},{"name":"ModularDesign","comment":"\n\n## Assemble your UI from modular, modifiable HTML components\n\nThe `ModularDesign` package provides an alternative, non-standard API for\ngenerating HTML and building reactive user interfaces in Elm. The package is\nbuilt on top of the standard `VirtualDom` and `Html` libraries, so the\nunderlying JavaScript implementation is no different.\n\nThe main disadvantage of the standard API is that once a chunk of HTML has been\nconstructed, e.g.,\n\n    welcomeMessage =\n      div [] [ p [] [ text \"Hello, World!\" ] ]\n\nthere is no direct way of looking inside that chunk to get information about its\nelements or their attributes. For example, it would not be possible to pass\n`welcomeMessage` to a function that would add a style attribute to the `p`\nelement or change the text to \"Hello, Universe!\" and return the result. With the\nstandard libraries, to make either of these modifications, we would need to\nre-write the nested `Html` function calls with modified arguments or insert\nconditionals that would change the arguments passed to the function in response\nto data. This limitation takes away some of the appeal of using a functional\nstyle of programming for front-end web development.\n\nThe `ModularDesign` library solves this problem by creating a set of types that\nprovide a representation of the HTML DOM in Elm, allowing access to each node's\ninternal data. In the Modular Design API, an `HtmlElement` is a record that\nencodes an element's tag, assigned class names, other assigned attributes, and,\nwhen applicable, its internal text, event handlers, and/or the type of input it\ncaptures. The union type `HtmlTree` defines a recursive tree where each node\ncontains an `HtmlElement` and some nodes also contain a list of child `HtmlTree`\nnodes. This data structure allows an `HtmlTree` to be passed to a function that\nwill access its internal data, build a modified `HtmlTree`, and return the\nresult, just as one can do with any other Elm type.\n\nWith the Modular Design API, the code to produce `welcomeMessage` may be\nwritten like this:\n\n    welcomeMessage =\n      container \"div\" [textWrapper \"p\" \"Hello, world!\"]\n\nOr, using functional operators, like this:\n\n    welcomeMessage =\n      \"Hello, world!\"\n        |> textWrapper \"p\"\n        |> wrapList\n        |> container \"div\"\n\nSuppose that we would like to be able to change the style of the text after this\nchunk of HTML has been encoded and assigned to a variable name. We can do this\nby adding a CSS class to the `p` element as follows:\n\n    welcomeMessage\n      |> modifyMatchingTag \"p\" (withClasses [\"large-bold-text\"])\n\nNote, however, that if there were multiple `p` elements in the tree, this\nfunction call would add the class \"large-bold-text\" to all of them. An\nalternative is to define the `id` attribute of the element we wish to modify and\nthen use the function `modifyMatchingId`:\n\n    welcomeMessage =\n      \"Hello, world!\"\n        |> textWrapper \"p\"\n        |> withId \"messageText\"\n        |> wrapList\n        |> container \"div\"\n\n    welcomeMessage\n      |> modifyMatchingId \"messageText\" (withClasses [\"large-bold-text\"])\n\nThe text of the message can be modified in a similar way:\n\n    welcomeMessage\n      |> modifyMatchingId \"messageText\" (withText \"Hello, Universe!\")\n\nAnd so on.\n\nFull working examples can be found [here](\"https://github.com/danielnarey/elm-modular-design/tree/master/examples).\n\nThe core package library includes basic constructors for `HtmlTree` nodes, sets\nof functions for modifying the element records of root nodes and internal nodes,\na function to render an `HtmlTree` to `VirtualDom`, and various helpers. A\nseparate package module, `ModularDesign.FormInput` provides an API for\ncapturing, accessing, and validating form input. Component and pattern libraries\nfor UI design are planned for future releases.\n\n\n# HTML DOM Representation\n@docs HtmlElement, TypedInput, HtmlTree\n\n# Rendering an `HtmlTree` to `VirtualDom`\n@docs assembleHtml\n\n# Node Constructors\n@docs leaf, textWrapper, container\n\n# Modifying the Root Node\n@docs appendNodes, withTag, withAttributes, withActions, withClasses, withStyles\n@docs removeClass, withText, withObserver, setInputType, withId\n\n# Modifying Internal Nodes\n@docs modifyMatchingId, modifyMatchingTag, modifyAll\n\n# Accessing `HtmlElement` Records\n@docs rootElement, listElements, getElementsByTag\n\n# Accessing Record Fields\n@docs getAttrValue, getId, hasValue\n\n# Generic Helpers\n@docs wrapList, thenTry\n\n","aliases":[{"name":"HtmlElement","comment":" Represents a HTML element with the following record fields:\n\n- __htmlTag__: A valid [HTML tag](http://www.w3schools.com/tags/). When\nrendering to `VirtualDom`, the tag is passed as a string argument to the\n[`Html.node`](http://package.elm-lang.org/packages/elm-lang/html/latest/Html#node)\nfunction.\n\n- __attributes__: A list of *name-value* pairs representing\n[HTML attributes](http://www.w3schools.com/tags/ref_attributes.asp). The\n[`Html.Attributes`](http://package.elm-lang.org/packages/elm-lang/html/latest/Html-Attributes)\nfunction corresponding to *name* will be called and, where necessary, the\n*value* will be converted from a string to the appropriate type (note that\nerrors in converting a boolean string to a `Bool` default to `False`). Any\n*name* for which there is no corresponding function will be passed to\n[`Html.Attributes.attribute`](http://package.elm-lang.org/packages/elm-lang/html/latest/Html-Attributes#attribute)\nalong with its *value*, creating a custom attribute.\n\n- __actions__: A list of *action-message* pairs. As defined here, \"actions\"\ninclude all events that __do not__ capture form input. Following the typical\npattern of an Elm program, a \"message\" is a user-defined type that tells the\nprogram what updates to perform on the model via pattern matching.\n\n- __classes__: A list of class names. The list is concatinated into one string\nand passed to\n[Html.Attributes.class](http://package.elm-lang.org/packages/elm-lang/html/latest/Html-Attributes#class).\n\n- __styles__: A list of *name-value* pairs representing\n[CSS properties](http://www.w3schools.com/cssref/).\nThe list is passed to\n[Html.Attributes.style](http://package.elm-lang.org/packages/elm-lang/html/latest/Html-Attributes#style).\nIt is generally better practice to set CSS classes on elements and the define\nstyles in a CSS file, but the style attribute can be used to override class\ndefaults.\n\n- __text__: A string of text, or `Nothing`. When rendered as HTML, text will be\ninserted after the element tag and before any child elements.\n\n- __observer__: An\n[`Html.Attribute`](http://package.elm-lang.org/packages/elm-lang/html/latest/Html#Attribute)\nencoding an event handler that captures form input, or `Nothing`. An \"observer\"\ndiffers from an \"action\" in that it captures one or more input values, and so\nrequires a `Json`\n[`Decoder`](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Decode#Decoder)\nto read that input. The built-in observers in the `Html.Events` library\nare\n[`onInput`](http://package.elm-lang.org/packages/elm-lang/html/latest/Html-Events#onInput)\nand\n[`onCheck`](http://package.elm-lang.org/packages/elm-lang/html/latest/Html-Events#onCheck).\nCustom observers may be created using the\n[`Html.Events.on`](http://package.elm-lang.org/packages/elm-lang/html/latest/Html-Events#on)\nfunction, which takes an\n[event name](http://www.w3schools.com/jsref/dom_obj_event.asp) (as a string,\nwithout the \"on\" prefix) and a\n[`Decoder`](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Decode#Decoder)\nas arguments. The Modular Design API also includes the helper functions\n`captureOnSubmit`, `fieldDecoder`, and `formDecoder`, which make it easier\nto construct observers for capturing form input.\n\n- __inputType__: A constructor that accepts a `Json` `Value` and returns\n`TypedInput`, or `Nothing`. The constructor may be one of: `StringInput`,\n`IntInput`, `FloatInput`, `BoolInput`, `NullInput`, `CustomInput`. This record\nfield is ignored when rendering the element to `VirtualDom`; its purpose is to\nallow form data to be aggregated while preserving type specifications on input\nfields, such that type checking can occur downstream in the program.\n","args":["msg"],"type":"{ htmlTag : String , attributes : List ( String, String ) , actions : List ( String, msg ) , classes : List String , styles : List ( String, String ) , text : Maybe.Maybe String , observer : Maybe.Maybe (Html.Attribute msg) , inputType : Maybe.Maybe (Json.Decode.Value -> ModularDesign.TypedInput) }"}],"types":[{"name":"HtmlTree","comment":" Represents a node in the DOM tree that may have some children (a `Stem`) or\nno children (a `Leaf`).\n","args":["msg"],"cases":[["Leaf",["ModularDesign.HtmlElement msg"]],["Stem",["ModularDesign.HtmlElement msg","List (ModularDesign.HtmlTree msg)"]]]},{"name":"TypedInput","comment":" Represents a JavaScript value with a type specification. Used to implement\ntype-checking in functions for capturing and reading form input. See the\n`ModularDesign.FormInput` documentation to find out how this works.\n","args":[],"cases":[["StringInput",["Json.Decode.Value"]],["IntInput",["Json.Decode.Value"]],["FloatInput",["Json.Decode.Value"]],["BoolInput",["Json.Decode.Value"]],["NullInput",["Json.Decode.Value"]],["CustomInput",["Json.Decode.Value"]]]}],"values":[{"name":"appendNodes","comment":" Append child nodes to the root node of an `HtmlTree`, replacing any existing\nchildren, and return the result. The main use of this function is to convert a\n`Leaf` to a `Stem`, which is helpful when nesting text elements.\n\n    \"Hello, world!\"\n      |> textWrapper \"p\"\n      |> appendNodes [ leaf \"br\", textWrapper \"strong\" \"Awesome!\" ]\n      |> container \"div\"\n\n    --> <div><p>Hello, world!<br><strong>Awesome!</strong></p></div>\n","type":"List (ModularDesign.HtmlTree msg) -> ModularDesign.HtmlTree msg -> ModularDesign.HtmlTree msg"},{"name":"assembleHtml","comment":" To render HTML in the browser, an `HtmlTree` must be converted to a\n[`VirtualDom.Node`](http://package.elm-lang.org/packages/elm-lang/virtual-dom/latest/VirtualDom#Node)\n(note that `Html.Html` is an alias for `VirtualDom.Node`). Calling\n`assembleHtml` on an `HtmlTree` recurses down the tree, constructing the\n`VirtualDom` representation node by node.\n","type":"ModularDesign.HtmlTree msg -> Html.Html msg"},{"name":"container","comment":" Create a `Stem` node with no attributes and no text.\n\n    \"Hello, world!\"\n      |> textWrapper \"p\"\n      |> container \"div\"\n\n    --> <div><p>Hello, world!</p></div>\n","type":"String -> List (ModularDesign.HtmlTree msg) -> ModularDesign.HtmlTree msg"},{"name":"getAttrValue","comment":" Given an `HtmlElement`, return the *value* for the attribute whose *name*\nmatching the first argument, or `Nothing` if no attribute with that *name* has\nbeen defined.\n\n    myElement\n      |> getAttrValue \"disabled\"\n","type":"String -> ModularDesign.HtmlElement msg -> Maybe.Maybe String"},{"name":"getElementsByTag","comment":" Given an `HtmlTree`, return a list containing every `HtmlElement` with an\n`htmlTag` matching the first argument.\n\n    myPage\n      |> getElementsByTag \"a\"\n","type":"String -> ModularDesign.HtmlTree msg -> List (ModularDesign.HtmlElement msg)"},{"name":"getId","comment":" Given an `HtmlElement`, return the *value* of its `id` attribute, or\n`Nothing` if the `id` attribute has not been defined.\n","type":"ModularDesign.HtmlElement msg -> Maybe.Maybe String"},{"name":"hasValue","comment":" Given an `HtmlElement`, lookup the attribute whose *name* matches the first\nargument; if its *value* matches the second argument, return `True`; if the\n*value* does not match, or the *name* is not found, return `False`.\n\n    if (rootElement myButton |> \"disabled\" `hasValue` \"True\") then\n      myButton\n        |> withAttributes [ (\"disabled\", \"False\") ]\n    else\n      myButton\n","type":"String -> String -> ModularDesign.HtmlElement msg -> Bool"},{"name":"leaf","comment":" Create a `Leaf` node with no attributes and no text.\n\n    leaf \"br\"   --> <br>\n","type":"String -> ModularDesign.HtmlTree msg"},{"name":"listElements","comment":" Given an `HtmlTree`, return a list containing every `HtmlElement` in the\ntree. This flattens the tree to provide more convenient access to record\nfields.\n","type":"ModularDesign.HtmlTree msg -> List (ModularDesign.HtmlElement msg)"},{"name":"modifyAll","comment":" Apply the modify function to every node in the tree.\n\n    newAttribute =\n      wrapList (\"hidden\", \"True\")\n\n    page\n      |> modifyAll (withAttributes newAttribute)\n","type":"(ModularDesign.HtmlTree msg -> ModularDesign.HtmlTree msg) -> ModularDesign.HtmlTree msg -> ModularDesign.HtmlTree msg"},{"name":"modifyMatchingId","comment":" Given a string representing an `id` and a modify function that accepts an\n`HtmlTree` and returns a modified `HtmlTree`, apply the modify function to\nevery node in the tree whose root element has a matching `id`. Note that HTML\nelements should be assigned unique `id` strings, so in theory the modify\nfunction should only be applied to one node.\n\n    welcomeMessage =\n      \"Hello, world!\"\n        |> textWrapper \"p\"\n        |> withId \"messageText\"\n        |> wrapList\n        |> container \"div\"\n\n    welcomeMessage\n      |> modifyMatchingId \"messageText\" (withText \"Hello, Universe!\")\n","type":"String -> (ModularDesign.HtmlTree msg -> ModularDesign.HtmlTree msg) -> ModularDesign.HtmlTree msg -> ModularDesign.HtmlTree msg"},{"name":"modifyMatchingTag","comment":" Given a string representing an HTML tag and a modify function that accepts an\n`HtmlTree` and returns a modified `HtmlTree`, apply the modify function to\nevery node in the tree whose root element has a matching HTML tag.\n\n    newAttribute =\n      wrapList (\"disabled\", \"True\")\n\n    page\n      |> modifyMatchingTag \"button\" (withAttributes newAttribute)\n","type":"String -> (ModularDesign.HtmlTree msg -> ModularDesign.HtmlTree msg) -> ModularDesign.HtmlTree msg -> ModularDesign.HtmlTree msg"},{"name":"removeClass","comment":" Remove a class name from the element at the root node of an `HtmlTree`.\n\n    welcomeMessage\n      |> removeClass \"large-text\"\n","type":"String -> ModularDesign.HtmlTree msg -> ModularDesign.HtmlTree msg"},{"name":"rootElement","comment":" Given an `HtmlTree`, return the `HtmlElement` at its root node.\n","type":"ModularDesign.HtmlTree msg -> ModularDesign.HtmlElement msg"},{"name":"setInputType","comment":" Set an input type for the root node of an `HtmlTree`. May be one of:\n`StringInput`, `IntInput`, `FloatInput`, `BoolInput`, `NullInput`,\n`CustomInput`.\n\n    leaf \"input\"\n      |> withAttributes [ (\"type\", \"text\"), (\"id\", \"birthYear\") ]\n      |> setInputType IntInput\n\nSee FieldDecoder.elm for a full working example.\n","type":"(Json.Decode.Value -> ModularDesign.TypedInput) -> ModularDesign.HtmlTree msg -> ModularDesign.HtmlTree msg"},{"name":"textWrapper","comment":" Create a `Leaf` node with text and no attributes.\n\n    \"Hello, world!\"\n      |> textWrapper \"p\"\n\n    --> <p>Hello, world!</p>\n","type":"String -> String -> ModularDesign.HtmlTree msg"},{"name":"thenTry","comment":" Same as\n[`Result.andThen`](http://package.elm-lang.org/packages/elm-lang/core/latest/Result#andThen),\nbut flips the order of the arguments, allowing for cleaner syntax when used with\nthe `|>` operator.\n\n    formInput\n      |> getInputAt \"birthYear\"\n      |> thenTry readIntInput\n      |> Result.withDefault -1\n","type":"(a -> Result.Result x b) -> Result.Result x a -> Result.Result x b"},{"name":"withActions","comment":" Add a list of actions to the element at the root node of an `HtmlTree`,\nencoded as *action-message* pairs. As defined here, \"actions\" include all events\nthat __do not__ capture form input. Following the typical pattern of an Elm\nprogram, a \"message\" is a user-defined type that tells the program what updates\nto perform on the model via pattern matching. If a new *action-message* pair has\nthe same *action* as an existing one, the new *message* replaces the old one;\notherwise, existing *action-message* pairs are retained.\n\n    \"Click here and see what happens!\"\n      |> textWrapper \"p\"\n      |> withAttributes [ (\"hidden\", toString model)]\n      |> withActions [ (\"click\", HideMessage) ]\n\nSee Actions.elm for a full working example.\n","type":"List ( String, msg ) -> ModularDesign.HtmlTree msg -> ModularDesign.HtmlTree msg"},{"name":"withAttributes","comment":" Add a list of attributes (*name-value* pairs) to the element at the root\nnode of an `HtmlTree`. If a new attribute has the same *name* as an existing\nattribute, the new *value* replaces the old one; otherwise, existing attributes\nare retained.\n\n    welcomeMessage\n      |> withAttributes [ (\"id\", \"welcomeMessage\") ]\n","type":"List ( String, String ) -> ModularDesign.HtmlTree msg -> ModularDesign.HtmlTree msg"},{"name":"withClasses","comment":" Add a list of class names to the element at the root node of an `HtmlTree`.\nAny existing class names are retained.\n\n    welcomeMessage =\n      \"Hello, world!\"\n        |> textWrapper \"p\"\n        |> withClasses [ \"large-text\", \"align-center\" ]\n","type":"List String -> ModularDesign.HtmlTree msg -> ModularDesign.HtmlTree msg"},{"name":"withId","comment":" Convenience function to add an `id` attribute to the root element of an\n`HtmlTree`. Calls `withAttributes`.\n\n    welcomeMessage\n      |> withId \"welcomeMessage\"\n","type":"String -> ModularDesign.HtmlTree msg -> ModularDesign.HtmlTree msg"},{"name":"withObserver","comment":" Add an observer to the element at the root node of an `HtmlTree`, encoded as\nan [`Html.Attribute`](http://package.elm-lang.org/packages/elm-lang/html/latest/Html#Attribute).\nAn \"observer\" differs from an \"action\" in that it captures one or more input\nvalues, and so requires a `Json`\n[`Decoder`](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Decode#Decoder)\nto read that input. The built-in observers in the `Html.Events` package\nare\n[`onInput`](http://package.elm-lang.org/packages/elm-lang/html/latest/Html-Events#onInput)\nand\n[`onCheck`](http://package.elm-lang.org/packages/elm-lang/html/latest/Html-Events#onCheck).\nCustom observers may be created using the\n[`Html.Events.on`](http://package.elm-lang.org/packages/elm-lang/html/latest/Html-Events#on)\nfunction, which takes an\n[event name](http://www.w3schools.com/jsref/dom_obj_event.asp) (as a string,\nwithout the \"on\" prefix) and a\n[`Decoder`](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Decode#Decoder)\nas arguments. The Modular Design API also includes the helper functions\n`captureOnSubmit`, `fieldDecoder`, and `formDecoder`, which make it easier\nto construct observers for capturing form input.\n\n    leaf \"input\"\n      |> withAttributes [ (\"type\", \"checkbox\"), (\"checked\", toString model) ]\n      |> withObserver (Events.onCheck Checked)\n\nSee Observers.elm for a full working example.\n","type":"Html.Attribute msg -> ModularDesign.HtmlTree msg -> ModularDesign.HtmlTree msg"},{"name":"withStyles","comment":" Add a list of styles to the element at the root node of an `HtmlTree`,\nencoded as *name-value* pairs. If a new style has the same *name* as an\nexisting style, the new *value* replaces the old one; otherwise, existing\nstyles are retained. It is generally better practice to set CSS classes on\nelements and the define styles in a CSS file, but the style attribute can be\nused to override class defaults.\n\n    welcomeMessage =\n      \"Hello, world!\"\n        |> textWrapper \"p\"\n        |> withStyles [ (\"font-size\", \"2em\"), (\"text-align\", \"center\") ]\n","type":"List ( String, String ) -> ModularDesign.HtmlTree msg -> ModularDesign.HtmlTree msg"},{"name":"withTag","comment":" Modify the HTML tag of the element at the root node of an `HtmlTree`.\nReplaces the existing tag.\n\n    welcomeMessage =\n      \"Hello, world!\"\n        |> textWrapper \"p\"\n\n    welcomeMessage\n      |> withTag \"span\"\n","type":"String -> ModularDesign.HtmlTree msg -> ModularDesign.HtmlTree msg"},{"name":"withText","comment":" Modify the text of the element at the root node of an `HtmlTree`. Replaces\nany existing text.\n\n    welcomeMessage =\n      leaf \"p\"\n        |> withText \"Hello, world!\"\n","type":"String -> ModularDesign.HtmlTree msg -> ModularDesign.HtmlTree msg"},{"name":"wrapList","comment":" Return a one-item list containing the argument\n\n    wrapList (\"key\", \"value\")   --> [ (\"key\", \"value\") ]\n","type":"a -> List a"}],"generated-with-elm-version":"0.17.0"}]