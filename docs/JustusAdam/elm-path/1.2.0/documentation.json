[
  {
    "name": "Path.Generic",
    "comment": "\n  Functions for working with paths, parameterized over the platform.\n\n  If you use the specialized versions from 'Path.Windows', 'Path.Posix' or 'Path.Url' the 'Platform' parameter is to be omitted.\n\n  # Platforms\n  @docs Platform\n\n  # Separator predicates\n  @docs pathSeparator, pathSeparators, isPathSeparator, extSeparator, isExtSeparator\n\n  # Extension functions\n  @dosc splitExtension, takeExtension, replaceExtension, (-<.>), dropExtension, addExtension, hasExtension, (<.>), splitExtensions, dropExtensions, takeExtensions\n\n  # Filename/directory functions\n  @docs splitFileName, takeFileName, replaceFileName, dropFileName, takeBaseName, replaceBaseName, takeDirectory, replaceDirectory, combine, splitPath, joinPath\n\n  # Trailing slash functions\n  @docs hasTrailingPathSeparator, addTrailingPathSeparator, dropTrailingPathSeparator",
    "aliases": [],
    "types": [
      {
        "name": "Platform",
        "comment": "\n  Available platforms for path manipulations.\n\n  Windows, Posix are relatively self explanatory\n\n  Url is specialized to filepaths as used on the web",
        "args": [],
        "cases": [
          [
            "Posix",
            []
          ],
          [
            "Windows",
            []
          ],
          [
            "Url",
            []
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "-<.>",
        "comment": "",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "type",
              "name": "String"
            }
          }
        },
        "associativity": "right",
        "precedence": 7
      },
      {
        "name": "<.>",
        "comment": "",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "type",
              "name": "String"
            }
          }
        },
        "associativity": "right",
        "precedence": 7
      },
      {
        "name": "addExtension",
        "comment": "\n  Add an extension, even if there is already one there, equivalent to '<.>'.\n\n  > addExtension \"/directory/path\" \"ext\" == \"/directory/path.ext\"\n  > addExtension \"file.txt\" \"bib\" == \"file.txt.bib\"\n  > addExtension \"file.\" \".bib\" == \"file..bib\"\n  > addExtension \"file\" \".bib\" == \"file.bib\"\n  > addExtension \"/\" \"x\" == \"/.x\"\n  > Valid x => takeFileName (addExtension (addTrailingPathSeparator x) \"ext\") == \".ext\"\n  > Windows: addExtension \"\\\\\\\\share\" \".txt\" == \"\\\\\\\\share\\\\.txt\"",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "type",
              "name": "String"
            }
          }
        }
      },
      {
        "name": "addTrailingPathSeparator",
        "comment": "\n  Add a trailing file path separator if one is not already present.\n\n  > hasTrailingPathSeparator (addTrailingPathSeparator x)\n  > hasTrailingPathSeparator x ==> addTrailingPathSeparator x == x\n  > Posix:    addTrailingPathSeparator \"test/rest\" == \"test/rest/\"",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Platform"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "type",
              "name": "String"
            }
          }
        }
      },
      {
        "name": "combine",
        "comment": "\n  Combine two paths, if the second path starts with a path separator then it returns the second.\n\n  > Valid x => combine (takeDirectory x) (takeFileName x) `equalFilePath` x\n\n  Combined:\n  > Posix:   combine \"/\" \"test\" == \"/test\"\n  > Posix:   combine \"home\" \"bob\" == \"home/bob\"\n  > Posix:   combine \"x:\" \"foo\" == \"x:/foo\"\n  > Windows: combine \"C:\\\\foo\" \"bar\" == \"C:\\\\foo\\\\bar\"\n  > Windows: combine \"home\" \"bob\" == \"home\\\\bob\"",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Platform"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "type",
                "name": "String"
              },
              "out": {
                "tag": "type",
                "name": "String"
              }
            }
          }
        }
      },
      {
        "name": "dropExtension",
        "comment": "\n  Remove last extension, and the \\\".\\\" preceding it.\n\n  > dropExtension \"/directory/path.ext\" == \"/directory/path\"\n  > dropExtension x == fst (splitExtension x)",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "String"
          }
        }
      },
      {
        "name": "dropExtensions",
        "comment": "\n  Drop all extensions.\n\n  > dropExtensions \"/directory/path.ext\" == \"/directory/path\"\n  > dropExtensions \"file.tar.gz\" == \"file\"\n  > not <| hasExtension <| dropExtensions x\n  > not <| any isExtSeparator <| takeFileName <| dropExtensions x",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "String"
          }
        }
      },
      {
        "name": "dropFileName",
        "comment": "\n  Drop the filename. Unlike 'takeDirectory', this function will leave\n  a trailing path separator on the directory.\n\n  > dropFileName \"/directory/file.ext\" == \"/directory/\"\n  > dropFileName x == fst (splitFileName x)",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Platform"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "type",
              "name": "String"
            }
          }
        }
      },
      {
        "name": "dropTrailingPathSeparator",
        "comment": "\n  Remove any trailing path separators\n\n  > dropTrailingPathSeparator \"file/test/\" == \"file/test\"\n  >           dropTrailingPathSeparator \"/\" == \"/\"\n  > Windows:  dropTrailingPathSeparator \"\\\\\" == \"\\\\\"",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Platform"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "type",
              "name": "String"
            }
          }
        }
      },
      {
        "name": "extSeparator",
        "comment": "\n  File extension character\n\n  > extSeparator == '.'",
        "type": {
          "tag": "type",
          "name": "String"
        }
      },
      {
        "name": "hasExtension",
        "comment": "\n  Does the given filename have an extension?\n\n  > hasExtension \"/directory/path.ext\" == True\n  > hasExtension \"/directory/path\" == False\n  > null (takeExtension x) == not (hasExtension x)",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        }
      },
      {
        "name": "hasTrailingPathSeparator",
        "comment": "\n  Is an item either a directory or the last character a path separator?\n\n  > hasTrailingPathSeparator \"test\" == False\n  > hasTrailingPathSeparator \"test/\" == True",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Platform"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "type",
              "name": "Bool"
            }
          }
        }
      },
      {
        "name": "isExtSeparator",
        "comment": "\n  Is the character an extension character?\n\n  > isExtSeparator a == (a == extSeparator)",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "Bool"
          }
        }
      },
      {
        "name": "isPathSeparator",
        "comment": "\n  Rather than using @(== 'pathSeparator')@, use this. Test if somethin is a path separator.\n\n  > isPathSeparator a == (a `elem` pathSeparators)",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Platform"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "type",
              "name": "Bool"
            }
          }
        }
      },
      {
        "name": "joinPath",
        "comment": "\n  Join path elements back together.\n\n  > joinPath [\"/\",\"directory/\",\"file.ext\"] == \"/directory/file.ext\"\n  > Valid x => joinPath (splitPath x) == x\n  > joinPath [] == \"\"\n  > Posix: joinPath [\"test\",\"file\",\"path\"] == \"test/file/path\"",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Platform"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "String"
                }
              ]
            },
            "out": {
              "tag": "type",
              "name": "String"
            }
          }
        }
      },
      {
        "name": "pathSeparator",
        "comment": "\n  The character that separates directories. In the case where more than\n  one character is possible, 'pathSeparator' is the \\'ideal\\' one.\n\n > Windows: pathSeparator == '\\\\'\n > Posix:   pathSeparator ==  '/'\n > isPathSeparator pathSeparator",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Platform"
          },
          "out": {
            "tag": "type",
            "name": "String"
          }
        }
      },
      {
        "name": "pathSeparators",
        "comment": "\n  The list of all possible separators.\n\n  > Windows: pathSeparators == ['\\\\', '/']\n  > Posix:   pathSeparators == ['/']\n  > pathSeparator `elem` pathSeparators",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Platform"
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "type",
                "name": "String"
              }
            ]
          }
        }
      },
      {
        "name": "replaceBaseName",
        "comment": "\n  Set the base name.\n\n  > replaceBaseName \"/directory/other.ext\" \"file\" == \"/directory/file.ext\"\n  > replaceBaseName \"file/test.txt\" \"bob\" == \"file/bob.txt\"\n  > replaceBaseName \"fred\" \"bill\" == \"bill\"\n  > replaceBaseName \"/dave/fred/bob.gz.tar\" \"new\" == \"/dave/fred/new.tar\"\n  > Valid x => replaceBaseName x (takeBaseName x) == x",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Platform"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "type",
                "name": "String"
              },
              "out": {
                "tag": "type",
                "name": "String"
              }
            }
          }
        }
      },
      {
        "name": "replaceDirectory",
        "comment": "\n  Set the directory, keeping the filename the same.\n\n  > replaceDirectory \"root/file.ext\" \"/directory/\" == \"/directory/file.ext\"\n  > Valid x => replaceDirectory x (takeDirectory x) `equalFilePath` x",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Platform"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "type",
                "name": "String"
              },
              "out": {
                "tag": "type",
                "name": "String"
              }
            }
          }
        }
      },
      {
        "name": "replaceExtension",
        "comment": "\n  Set the extension of a file, overwriting one if already present, equivalent to '-<.>'.\n\n  > replaceExtension \"/directory/path.txt\" \"ext\" == \"/directory/path.ext\"\n  > replaceExtension \"/directory/path.txt\" \".ext\" == \"/directory/path.ext\"\n  > replaceExtension \"file.txt\" \".bob\" == \"file.bob\"\n  > replaceExtension \"file.txt\" \"bob\" == \"file.bob\"\n  > replaceExtension \"file\" \".bob\" == \"file.bob\"\n  > replaceExtension \"file.txt\" \"\" == \"file\"\n  > replaceExtension \"file.fred.bob\" \"txt\" == \"file.fred.txt\"\n  > replaceExtension x y == addExtension (dropExtension x) y",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "type",
              "name": "String"
            }
          }
        }
      },
      {
        "name": "replaceFileName",
        "comment": "\n  Set the filename.\n\n  > replaceFileName \"/directory/other.txt\" \"file.ext\" == \"/directory/file.ext\"\n  > Valid x => replaceFileName x (takeFileName x) == x",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Platform"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "type",
                "name": "String"
              },
              "out": {
                "tag": "type",
                "name": "String"
              }
            }
          }
        }
      },
      {
        "name": "splitExtension",
        "comment": "\n  Split on the extension. 'addExtension' is the inverse.\n\n  > splitExtension \"/directory/path.ext\" == (\"/directory/path\",\".ext\")\n  > uncurry (++) (splitExtension x) == x\n  > Valid x => uncurry addExtension (splitExtension x) == x\n  > splitExtension \"file.txt\" == (\"file\",\".txt\")\n  > splitExtension \"file\" == (\"file\",\"\")\n  > splitExtension \"file/file.txt\" == (\"file/file\",\".txt\")\n  > splitExtension \"file.txt/boris\" == (\"file.txt/boris\",\"\")\n  > splitExtension \"file.txt/boris.ext\" == (\"file.txt/boris\",\".ext\")\n  > splitExtension \"file/path.txt.bob.fred\" == (\"file/path.txt.bob\",\".fred\")\n  > splitExtension \"file/path.txt/\" == (\"file/path.txt/\",\"\")",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "_Tuple2"
            },
            "args": [
              {
                "tag": "type",
                "name": "String"
              },
              {
                "tag": "type",
                "name": "String"
              }
            ]
          }
        }
      },
      {
        "name": "splitExtensions",
        "comment": "\n  Split on all extensions.\n\n  > splitExtensions \"/directory/path.ext\" == (\"/directory/path\",\".ext\")\n  > splitExtensions \"file.tar.gz\" == (\"file\",\".tar.gz\")\n  > uncurry (++) (splitExtensions x) == x\n  > Valid x => uncurry addExtension (splitExtensions x) == x\n  > splitExtensions \"file.tar.gz\" == (\"file\",\".tar.gz\")",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "_Tuple2"
            },
            "args": [
              {
                "tag": "type",
                "name": "String"
              },
              {
                "tag": "type",
                "name": "String"
              }
            ]
          }
        }
      },
      {
        "name": "splitFileName",
        "comment": "\n  Operations on a filepath, as a list of directories\n\n  | Split a filename into directory and file. 'combine' is the inverse.\n    The first component will often end with a trailing slash.\n\n  > splitFileName \"/directory/file.ext\" == (\"/directory/\",\"file.ext\")\n  > Valid x => isValid (fst (splitFileName x))\n  > splitFileName \"file/bob.txt\" == (\"file/\", \"bob.txt\")\n  > splitFileName \"file/\" == (\"file/\", \"\")\n  > splitFileName \"bob\" == (\"\", \"bob\")\n  > Posix:   splitFileName \"/\" == (\"/\",\"\")",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Platform"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "_Tuple2"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "String"
                },
                {
                  "tag": "type",
                  "name": "String"
                }
              ]
            }
          }
        }
      },
      {
        "name": "splitPath",
        "comment": "\n  Split a path by the directory separator.\n\n  > splitPath \"/directory/file.ext\" == [\"/\",\"directory/\",\"file.ext\"]\n  > concat (splitPath x) == x\n  > splitPath \"test//item/\" == [\"test//\",\"item/\"]\n  > splitPath \"test/item/file\" == [\"test/\",\"item/\",\"file\"]\n  > splitPath \"\" == []\n  > Windows: splitPath \"c:\\\\test\\\\path\" == [\"c:\\\\\",\"test\\\\\",\"path\"]\n  > Posix:   splitPath \"/file/test\" == [\"/\",\"file/\",\"test\"]",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Platform"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "String"
                }
              ]
            }
          }
        }
      },
      {
        "name": "takeBaseName",
        "comment": "\n  Get the base name, without an extension or path.\n\n  > takeBaseName \"/directory/file.ext\" == \"file\"\n  > takeBaseName \"file/test.txt\" == \"test\"\n  > takeBaseName \"dave.ext\" == \"dave\"\n  > takeBaseName \"\" == \"\"\n  > takeBaseName \"test\" == \"test\"\n  > takeBaseName (addTrailingPathSeparator x) == \"\"\n  > takeBaseName \"file/file.tar.gz\" == \"file.tar\"",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Platform"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "type",
              "name": "String"
            }
          }
        }
      },
      {
        "name": "takeDirectory",
        "comment": "\n  Get the directory name, move up one level.\n\n  >           takeDirectory \"/directory/other.ext\" == \"/directory\"\n  >           takeDirectory x `isPrefixOf` x || takeDirectory x == \".\"\n  >           takeDirectory \"foo\" == \".\"\n  >           takeDirectory \"/\" == \"/\"\n  >           takeDirectory \"/foo\" == \"/\"\n  >           takeDirectory \"/foo/bar/baz\" == \"/foo/bar\"\n  >           takeDirectory \"/foo/bar/baz/\" == \"/foo/bar/baz\"\n  >           takeDirectory \"foo/bar/baz\" == \"foo/bar\"\n  > Windows:  takeDirectory \"foo\\\\bar\" == \"foo\"\n  > Windows:  takeDirectory \"foo\\\\bar\\\\\\\\\" == \"foo\\\\bar\"",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Platform"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "type",
              "name": "String"
            }
          }
        }
      },
      {
        "name": "takeExtension",
        "comment": "\n  Get the extension of a file, returns @\\\"\\\"@ for no extension, @.ext@ otherwise.\n\n  > takeExtension \"/directory/path.ext\" == \".ext\"\n  > takeExtension x == snd (splitExtension x)\n  > Valid x => takeExtension (addExtension x \"ext\") == \".ext\"\n  > Valid x => takeExtension (replaceExtension x \"ext\") == \".ext\"",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "String"
          }
        }
      },
      {
        "name": "takeExtensions",
        "comment": "\n  Get all extensions.\n\n  > takeExtensions \"/directory/path.ext\" == \".ext\"\n  > takeExtensions \"file.tar.gz\" == \".tar.gz\"",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "String"
          }
        }
      },
      {
        "name": "takeFileName",
        "comment": "\n  Get the file name.\n\n  > takeFileName \"/directory/file.ext\" == \"file.ext\"\n  > takeFileName \"test/\" == \"\"\n  > takeFileName x `isSuffixOf` x\n  > takeFileName x == snd (splitFileName x)\n  > Valid x => takeFileName (replaceFileName x \"fred\") == \"fred\"\n  > Valid x => takeFileName (x </> \"fred\") == \"fred\"\n  > Valid x => isRelative (takeFileName x)",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Platform"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "type",
              "name": "String"
            }
          }
        }
      }
    ]
  },
  {
    "name": "Path.Posix",
    "comment": "\n  Specialized path manipulation functions for working with Posix paths. For documentation on the API refer to 'Path.Generic'.\n\n  Reexports all functions from the 'Path.Generic' module, specialized to Posix paths.\n\n  Since operator reexport does not seem to work, <.> and -<.> have to be imported from the Generic module directly.\n\n  # Specialized operators\n  @docs (</>)",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "</>",
        "comment": "\n  Operator Version of 'combine'",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "type",
              "name": "String"
            }
          }
        },
        "associativity": "right",
        "precedence": 5
      }
    ]
  },
  {
    "name": "Path.Windows",
    "comment": "\n  Specialized path manipulation functions for working with Windows paths. For documentation on the API refer to 'Path.Generic'.\n\n  This module is not very well tested. PLease make sure the functions you use work as expected.\n\n  Reexports all functions from the 'Path.Generic' module, specialized to Windows paths.\n\n  Since operator reexport does not seem to work, <.> and -<.> have to be imported from the Generic module directly.\n\n  # Specialized operators\n  @docs (</>)",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "</>",
        "comment": "\n  Operator Version of 'combine'",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "type",
              "name": "String"
            }
          }
        },
        "associativity": "right",
        "precedence": 5
      }
    ]
  },
  {
    "name": "Path.Url",
    "comment": "\n  Specialized path manipulation functions for working with filepaths as found on the web. For documentation on the API refer to 'Path.Generic'.\n\n  Reexports all functions from the 'Path.Generic' module, specialized to web related paths.\n\n  Since operator reexport does not seem to work, <.> and -<.> have to be imported from the Generic module directly.\n\n  # Specialized operators\n  @docs (</>)",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "</>",
        "comment": "\n  Operator Version of 'combine'",
        "type": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "type",
              "name": "String"
            }
          }
        },
        "associativity": "right",
        "precedence": 5
      }
    ]
  }
]